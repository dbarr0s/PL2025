Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> header block DOT
Rule 2     header -> PROGRAM IDENTIFIER SEMICOLON
Rule 3     block -> VAR variable_declaration body
Rule 4     block -> body
Rule 5     block -> function block
Rule 6     block -> procedure block
Rule 7     variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration
Rule 8     variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 9     identifier_list -> IDENTIFIER COMMA identifier_list
Rule 10    identifier_list -> IDENTIFIER
Rule 11    array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name
Rule 12    array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET
Rule 13    body -> BEGIN statements END
Rule 14    statements -> statement SEMICOLON statements
Rule 15    statements -> statement SEMICOLON
Rule 16    statement -> writeln
Rule 17    statement -> assignment
Rule 18    statement -> procedure_call
Rule 19    statement -> cond_if
Rule 20    statement -> while_loop
Rule 21    statement -> for_loop
Rule 22    statement -> repeat_loop
Rule 23    statement -> readln
Rule 24    assignment -> type ASSIGNMENT expressionGeneric
Rule 25    assignment -> type ASSIGNMENT length
Rule 26    assignment -> type ASSIGNMENT negation
Rule 27    expressionGeneric -> expression
Rule 28    expressionGeneric -> expressionGeneric comparator expression
Rule 29    expression -> term
Rule 30    expression -> expression operationAdd term
Rule 31    term -> fator
Rule 32    term -> term operationMul fator
Rule 33    fator -> type
Rule 34    expression_paren -> LPAREN expressionGeneric RPAREN
Rule 35    operationAdd -> plus
Rule 36    operationAdd -> minus
Rule 37    operationAdd -> div
Rule 38    operationAdd -> mod
Rule 39    operationAdd -> RANGE
Rule 40    operationMul -> times
Rule 41    operationMul -> division
Rule 42    type_name -> NINTEGER
Rule 43    type_name -> NREAL
Rule 44    type_name -> NSTRING
Rule 45    type_name -> NCHAR
Rule 46    type_name -> NBOOLEAN
Rule 47    type_name -> array_type
Rule 48    type -> integer
Rule 49    type -> real
Rule 50    type -> string
Rule 51    type -> char
Rule 52    type -> boolean
Rule 53    type -> identifier
Rule 54    type -> func_call
Rule 55    type -> array_access
Rule 56    type -> expression_paren
Rule 57    integer -> INTEGER
Rule 58    real -> REAL
Rule 59    string -> STRING
Rule 60    char -> CHAR
Rule 61    boolean -> BOOLEAN
Rule 62    identifier -> IDENTIFIER
Rule 63    plus -> PLUS
Rule 64    minus -> MINUS
Rule 65    times -> TIMES
Rule 66    division -> DIVISION
Rule 67    div -> DIV
Rule 68    mod -> MOD
Rule 69    comparator -> eq
Rule 70    comparator -> neq
Rule 71    comparator -> lt
Rule 72    comparator -> gt
Rule 73    comparator -> lte
Rule 74    comparator -> gte
Rule 75    comparator -> and
Rule 76    comparator -> or
Rule 77    comparator -> not
Rule 78    eq -> EQ
Rule 79    neq -> NEQ
Rule 80    lt -> LT
Rule 81    gt -> GT
Rule 82    lte -> LTE
Rule 83    gte -> GTE
Rule 84    and -> AND
Rule 85    or -> OR
Rule 86    not -> NOT
Rule 87    negation -> not boolean
Rule 88    negation -> not func_call
Rule 89    procedure -> procedure_no_args_no_vars
Rule 90    procedure -> procedure_args_no_vars
Rule 91    procedure -> procedure_no_args_vars
Rule 92    procedure -> procedure_args_vars
Rule 93    procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
Rule 94    procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
Rule 95    procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
Rule 96    procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
Rule 97    procedure_variable_declaration -> identifier_list COLON type_name SEMICOLON procedure_variable_declaration
Rule 98    procedure_variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 99    procedure_body -> BEGIN statements END
Rule 100   procedure_call -> prepare_func_call
Rule 101   procedure_call -> prepare_func_call LPAREN procedure_arg_list RPAREN
Rule 102   procedure_arg_list -> expressionGeneric COMMA procedure_arg_list
Rule 103   procedure_arg_list -> expressionGeneric
Rule 104   length -> LENGTH LPAREN type RPAREN
Rule 105   function -> function_with_vars
Rule 106   function -> function_with_no_vars
Rule 107   function_with_vars -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
Rule 108   function_with_no_vars -> func_header SEMICOLON func_body SEMICOLON
Rule 109   func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
Rule 110   func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name
Rule 111   func_args -> func_arglist SEMICOLON func_args
Rule 112   func_args -> func_arglist
Rule 113   func_arglist -> identifier_list COLON type_name
Rule 114   func_variable_declaration -> identifier_list COLON type_name SEMICOLON func_variable_declaration
Rule 115   func_variable_declaration -> identifier_list COLON type_name SEMICOLON
Rule 116   func_body -> BEGIN statements END
Rule 117   func_call -> prepare_func_call LPAREN arg_list RPAREN
Rule 118   prepare_func_call -> IDENTIFIER
Rule 119   arg_list -> expressionGeneric COMMA arg_list
Rule 120   arg_list -> expressionGeneric
Rule 121   arg_list -> <empty>
Rule 122   cond_if -> IF condition THEN statement
Rule 123   cond_if -> IF condition THEN statement ELSE statement
Rule 124   cond_if -> IF condition THEN statement ELSE if_body
Rule 125   cond_if -> IF condition THEN if_body
Rule 126   cond_if -> IF condition THEN if_body ELSE if_body
Rule 127   cond_if -> IF condition THEN if_body ELSE statement
Rule 128   condition -> expressionGeneric
Rule 129   if_body -> BEGIN statements END
Rule 130   to -> TO
Rule 131   downto -> DOWNTO
Rule 132   for_loop -> FOR assignment to type DO statement
Rule 133   for_loop -> FOR assignment to type DO if_body
Rule 134   for_loop -> FOR assignment downto type DO statement
Rule 135   for_loop -> FOR assignment downto type DO if_body
Rule 136   while_loop -> WHILE condition DO statement
Rule 137   while_loop -> WHILE condition DO if_body
Rule 138   repeat_loop -> REPEAT statements UNTIL condition
Rule 139   readln -> READLN LPAREN type RPAREN
Rule 140   writeln -> WRITELN LPAREN writeln_args RPAREN
Rule 141   writeln_args -> type COMMA writeln_args
Rule 142   writeln_args -> type

Terminals, with rules where they appear

AND                  : 84
ARRAY                : 11
ASSIGNMENT           : 24 25 26
BEGIN                : 13 99 116 129
BOOLEAN              : 61
CHAR                 : 60
COLON                : 7 8 97 98 109 110 113 114 115
COMMA                : 9 102 119 141
COMMENT              : 
DIV                  : 67
DIVISION             : 66
DO                   : 132 133 134 135 136 137
DOT                  : 1
DOWNTO               : 131
ELSE                 : 123 124 126 127
END                  : 13 99 116 129
EQ                   : 78
FOR                  : 132 133 134 135
FUNCTION             : 109 110
GT                   : 81
GTE                  : 83
IDENTIFIER           : 2 9 10 12 62 93 94 95 96 109 110 118
IF                   : 122 123 124 125 126 127
INTEGER              : 57
LBRACKET             : 11 12
LENGTH               : 104
LPAREN               : 34 94 96 101 104 109 110 117 139 140
LT                   : 80
LTE                  : 82
MINUS                : 64
MOD                  : 68
NBOOLEAN             : 46
NCHAR                : 45
NEQ                  : 79
NINTEGER             : 42
NOT                  : 86
NREAL                : 43
NSTRING              : 44
OF                   : 11
OR                   : 85
PLUS                 : 63
PROCEDURE            : 93 94 95 96
PROGRAM              : 2
RANGE                : 11 39
RBRACKET             : 11 12
READLN               : 139
REAL                 : 58
REPEAT               : 138
RPAREN               : 34 94 96 101 104 109 110 117 139 140
SEMICOLON            : 2 7 8 14 15 93 93 94 94 95 95 96 96 97 98 107 107 108 108 111 114 115
STRING               : 59
THEN                 : 122 123 124 125 126 127
TIMES                : 65
TO                   : 130
UNTIL                : 138
VAR                  : 3 95 96 107
WHILE                : 136 137
WRITELN              : 140
error                : 

Nonterminals, with rules where they appear

and                  : 75
arg_list             : 117 119
array_access         : 55
array_type           : 47
assignment           : 17 132 133 134 135
block                : 1 5 6
body                 : 3 4
boolean              : 52 87
char                 : 51
comparator           : 28
cond_if              : 19
condition            : 122 123 124 125 126 127 136 137 138
div                  : 37
division             : 41
downto               : 134 135
eq                   : 69
expression           : 27 28 30
expressionGeneric    : 12 24 28 34 102 103 119 120 128
expression_paren     : 56
fator                : 31 32
for_loop             : 21
func_arglist         : 111 112
func_args            : 94 96 109 111
func_body            : 107 108
func_call            : 54 88
func_header          : 107 108
func_variable_declaration : 95 96 107 114
function             : 5
function_with_no_vars : 106
function_with_vars   : 105
gt                   : 72
gte                  : 74
header               : 1
identifier           : 53
identifier_list      : 7 8 9 97 98 113 114 115
if_body              : 124 125 126 126 127 133 135 137
integer              : 48
length               : 25
lt                   : 71
lte                  : 73
minus                : 36
mod                  : 38
negation             : 26
neq                  : 70
not                  : 77 87 88
operationAdd         : 30
operationMul         : 32
or                   : 76
plus                 : 35
prepare_func_call    : 100 101 117
procedure            : 6
procedure_arg_list   : 101 102
procedure_args_no_vars : 90
procedure_args_vars  : 92
procedure_body       : 93 94 95 96
procedure_call       : 18
procedure_no_args_no_vars : 89
procedure_no_args_vars : 91
procedure_variable_declaration : 97
program              : 0
readln               : 23
real                 : 49
repeat_loop          : 22
statement            : 14 15 122 123 123 124 127 132 134 136
statements           : 13 14 99 116 129 138
string               : 50
term                 : 29 30 32
times                : 40
to                   : 132 133
type                 : 11 11 24 25 26 33 104 132 133 134 135 139 141 142
type_name            : 7 8 11 97 98 109 110 113 114 115
variable_declaration : 3 7
while_loop           : 20
writeln              : 16
writeln_args         : 140 141

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . header block DOT
    (2) header -> . PROGRAM IDENTIFIER SEMICOLON

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    header                         shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> header . block DOT
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (13) body -> . BEGIN statements END
    (105) function -> . function_with_vars
    (106) function -> . function_with_no_vars
    (89) procedure -> . procedure_no_args_no_vars
    (90) procedure -> . procedure_args_no_vars
    (91) procedure -> . procedure_no_args_vars
    (92) procedure -> . procedure_args_vars
    (107) function_with_vars -> . func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (108) function_with_no_vars -> . func_header SEMICOLON func_body SEMICOLON
    (93) procedure_no_args_no_vars -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (94) procedure_args_no_vars -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (95) procedure_no_args_vars -> . PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (96) procedure_args_vars -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (109) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (110) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 17
    FUNCTION        shift and go to state 18

    block                          shift and go to state 4
    body                           shift and go to state 6
    function                       shift and go to state 7
    procedure                      shift and go to state 8
    function_with_vars             shift and go to state 10
    function_with_no_vars          shift and go to state 11
    procedure_no_args_no_vars      shift and go to state 12
    procedure_args_no_vars         shift and go to state 13
    procedure_no_args_vars         shift and go to state 14
    procedure_args_vars            shift and go to state 15
    func_header                    shift and go to state 16

state 3

    (2) header -> PROGRAM . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 19


state 4

    (1) program -> header block . DOT

    DOT             shift and go to state 20


state 5

    (3) block -> VAR . variable_declaration body
    (7) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 23

    variable_declaration           shift and go to state 21
    identifier_list                shift and go to state 22

state 6

    (4) block -> body .

    DOT             reduce using rule 4 (block -> body .)


state 7

    (5) block -> function . block
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (13) body -> . BEGIN statements END
    (105) function -> . function_with_vars
    (106) function -> . function_with_no_vars
    (89) procedure -> . procedure_no_args_no_vars
    (90) procedure -> . procedure_args_no_vars
    (91) procedure -> . procedure_no_args_vars
    (92) procedure -> . procedure_args_vars
    (107) function_with_vars -> . func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (108) function_with_no_vars -> . func_header SEMICOLON func_body SEMICOLON
    (93) procedure_no_args_no_vars -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (94) procedure_args_no_vars -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (95) procedure_no_args_vars -> . PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (96) procedure_args_vars -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (109) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (110) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 17
    FUNCTION        shift and go to state 18

    function                       shift and go to state 7
    block                          shift and go to state 24
    body                           shift and go to state 6
    procedure                      shift and go to state 8
    function_with_vars             shift and go to state 10
    function_with_no_vars          shift and go to state 11
    procedure_no_args_no_vars      shift and go to state 12
    procedure_args_no_vars         shift and go to state 13
    procedure_no_args_vars         shift and go to state 14
    procedure_args_vars            shift and go to state 15
    func_header                    shift and go to state 16

state 8

    (6) block -> procedure . block
    (3) block -> . VAR variable_declaration body
    (4) block -> . body
    (5) block -> . function block
    (6) block -> . procedure block
    (13) body -> . BEGIN statements END
    (105) function -> . function_with_vars
    (106) function -> . function_with_no_vars
    (89) procedure -> . procedure_no_args_no_vars
    (90) procedure -> . procedure_args_no_vars
    (91) procedure -> . procedure_no_args_vars
    (92) procedure -> . procedure_args_vars
    (107) function_with_vars -> . func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (108) function_with_no_vars -> . func_header SEMICOLON func_body SEMICOLON
    (93) procedure_no_args_no_vars -> . PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (94) procedure_args_no_vars -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (95) procedure_no_args_vars -> . PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (96) procedure_args_vars -> . PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (109) func_header -> . FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (110) func_header -> . FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name

    VAR             shift and go to state 5
    BEGIN           shift and go to state 9
    PROCEDURE       shift and go to state 17
    FUNCTION        shift and go to state 18

    procedure                      shift and go to state 8
    block                          shift and go to state 25
    body                           shift and go to state 6
    function                       shift and go to state 7
    function_with_vars             shift and go to state 10
    function_with_no_vars          shift and go to state 11
    procedure_no_args_no_vars      shift and go to state 12
    procedure_args_no_vars         shift and go to state 13
    procedure_no_args_vars         shift and go to state 14
    procedure_args_vars            shift and go to state 15
    func_header                    shift and go to state 16

state 9

    (13) body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (140) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT expressionGeneric
    (25) assignment -> . type ASSIGNMENT length
    (26) assignment -> . type ASSIGNMENT negation
    (100) procedure_call -> . prepare_func_call
    (101) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (122) cond_if -> . IF condition THEN statement
    (123) cond_if -> . IF condition THEN statement ELSE statement
    (124) cond_if -> . IF condition THEN statement ELSE if_body
    (125) cond_if -> . IF condition THEN if_body
    (126) cond_if -> . IF condition THEN if_body ELSE if_body
    (127) cond_if -> . IF condition THEN if_body ELSE statement
    (136) while_loop -> . WHILE condition DO statement
    (137) while_loop -> . WHILE condition DO if_body
    (132) for_loop -> . FOR assignment to type DO statement
    (133) for_loop -> . FOR assignment to type DO if_body
    (134) for_loop -> . FOR assignment downto type DO statement
    (135) for_loop -> . FOR assignment downto type DO if_body
    (138) repeat_loop -> . REPEAT statements UNTIL condition
    (139) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (118) prepare_func_call -> . IDENTIFIER
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN

    WRITELN         shift and go to state 36
    IF              shift and go to state 40
    WHILE           shift and go to state 41
    FOR             shift and go to state 42
    REPEAT          shift and go to state 43
    READLN          shift and go to state 44
    IDENTIFIER      shift and go to state 54
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    LPAREN          shift and go to state 37

    statements                     shift and go to state 26
    statement                      shift and go to state 27
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 38
    prepare_func_call              shift and go to state 39
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53

state 10

    (105) function -> function_with_vars .

    VAR             reduce using rule 105 (function -> function_with_vars .)
    BEGIN           reduce using rule 105 (function -> function_with_vars .)
    PROCEDURE       reduce using rule 105 (function -> function_with_vars .)
    FUNCTION        reduce using rule 105 (function -> function_with_vars .)


state 11

    (106) function -> function_with_no_vars .

    VAR             reduce using rule 106 (function -> function_with_no_vars .)
    BEGIN           reduce using rule 106 (function -> function_with_no_vars .)
    PROCEDURE       reduce using rule 106 (function -> function_with_no_vars .)
    FUNCTION        reduce using rule 106 (function -> function_with_no_vars .)


state 12

    (89) procedure -> procedure_no_args_no_vars .

    VAR             reduce using rule 89 (procedure -> procedure_no_args_no_vars .)
    BEGIN           reduce using rule 89 (procedure -> procedure_no_args_no_vars .)
    PROCEDURE       reduce using rule 89 (procedure -> procedure_no_args_no_vars .)
    FUNCTION        reduce using rule 89 (procedure -> procedure_no_args_no_vars .)


state 13

    (90) procedure -> procedure_args_no_vars .

    VAR             reduce using rule 90 (procedure -> procedure_args_no_vars .)
    BEGIN           reduce using rule 90 (procedure -> procedure_args_no_vars .)
    PROCEDURE       reduce using rule 90 (procedure -> procedure_args_no_vars .)
    FUNCTION        reduce using rule 90 (procedure -> procedure_args_no_vars .)


state 14

    (91) procedure -> procedure_no_args_vars .

    VAR             reduce using rule 91 (procedure -> procedure_no_args_vars .)
    BEGIN           reduce using rule 91 (procedure -> procedure_no_args_vars .)
    PROCEDURE       reduce using rule 91 (procedure -> procedure_no_args_vars .)
    FUNCTION        reduce using rule 91 (procedure -> procedure_no_args_vars .)


state 15

    (92) procedure -> procedure_args_vars .

    VAR             reduce using rule 92 (procedure -> procedure_args_vars .)
    BEGIN           reduce using rule 92 (procedure -> procedure_args_vars .)
    PROCEDURE       reduce using rule 92 (procedure -> procedure_args_vars .)
    FUNCTION        reduce using rule 92 (procedure -> procedure_args_vars .)


state 16

    (107) function_with_vars -> func_header . SEMICOLON VAR func_variable_declaration func_body SEMICOLON
    (108) function_with_no_vars -> func_header . SEMICOLON func_body SEMICOLON

    SEMICOLON       shift and go to state 60


state 17

    (93) procedure_no_args_no_vars -> PROCEDURE . IDENTIFIER SEMICOLON procedure_body SEMICOLON
    (94) procedure_args_no_vars -> PROCEDURE . IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (95) procedure_no_args_vars -> PROCEDURE . IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (96) procedure_args_vars -> PROCEDURE . IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON

    IDENTIFIER      shift and go to state 61


state 18

    (109) func_header -> FUNCTION . IDENTIFIER LPAREN func_args RPAREN COLON type_name
    (110) func_header -> FUNCTION . IDENTIFIER LPAREN RPAREN COLON type_name

    IDENTIFIER      shift and go to state 62


state 19

    (2) header -> PROGRAM IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 63


state 20

    (1) program -> header block DOT .

    $end            reduce using rule 1 (program -> header block DOT .)


state 21

    (3) block -> VAR variable_declaration . body
    (13) body -> . BEGIN statements END

    BEGIN           shift and go to state 9

    body                           shift and go to state 64

state 22

    (7) variable_declaration -> identifier_list . COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list . COLON type_name SEMICOLON

    COLON           shift and go to state 65


state 23

    (9) identifier_list -> IDENTIFIER . COMMA identifier_list
    (10) identifier_list -> IDENTIFIER .

    COMMA           shift and go to state 66
    COLON           reduce using rule 10 (identifier_list -> IDENTIFIER .)


state 24

    (5) block -> function block .

    DOT             reduce using rule 5 (block -> function block .)


state 25

    (6) block -> procedure block .

    DOT             reduce using rule 6 (block -> procedure block .)


state 26

    (13) body -> BEGIN statements . END

    END             shift and go to state 67


state 27

    (14) statements -> statement . SEMICOLON statements
    (15) statements -> statement . SEMICOLON

    SEMICOLON       shift and go to state 68


state 28

    (16) statement -> writeln .

    SEMICOLON       reduce using rule 16 (statement -> writeln .)
    ELSE            reduce using rule 16 (statement -> writeln .)


state 29

    (17) statement -> assignment .

    SEMICOLON       reduce using rule 17 (statement -> assignment .)
    ELSE            reduce using rule 17 (statement -> assignment .)


state 30

    (18) statement -> procedure_call .

    SEMICOLON       reduce using rule 18 (statement -> procedure_call .)
    ELSE            reduce using rule 18 (statement -> procedure_call .)


state 31

    (19) statement -> cond_if .

    SEMICOLON       reduce using rule 19 (statement -> cond_if .)
    ELSE            reduce using rule 19 (statement -> cond_if .)


state 32

    (20) statement -> while_loop .

    SEMICOLON       reduce using rule 20 (statement -> while_loop .)
    ELSE            reduce using rule 20 (statement -> while_loop .)


state 33

    (21) statement -> for_loop .

    SEMICOLON       reduce using rule 21 (statement -> for_loop .)
    ELSE            reduce using rule 21 (statement -> for_loop .)


state 34

    (22) statement -> repeat_loop .

    SEMICOLON       reduce using rule 22 (statement -> repeat_loop .)
    ELSE            reduce using rule 22 (statement -> repeat_loop .)


state 35

    (23) statement -> readln .

    SEMICOLON       reduce using rule 23 (statement -> readln .)
    ELSE            reduce using rule 23 (statement -> readln .)


state 36

    (140) writeln -> WRITELN . LPAREN writeln_args RPAREN

    LPAREN          shift and go to state 69


state 37

    (34) expression_paren -> LPAREN . expressionGeneric RPAREN
    (27) expressionGeneric -> . expression
    (28) expressionGeneric -> . expressionGeneric comparator expression
    (29) expression -> . term
    (30) expression -> . expression operationAdd term
    (31) term -> . fator
    (32) term -> . term operationMul fator
    (33) fator -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    expressionGeneric              shift and go to state 70
    expression                     shift and go to state 71
    term                           shift and go to state 72
    fator                          shift and go to state 73
    type                           shift and go to state 74
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 38

    (24) assignment -> type . ASSIGNMENT expressionGeneric
    (25) assignment -> type . ASSIGNMENT length
    (26) assignment -> type . ASSIGNMENT negation

    ASSIGNMENT      shift and go to state 77


state 39

    (100) procedure_call -> prepare_func_call .
    (101) procedure_call -> prepare_func_call . LPAREN procedure_arg_list RPAREN
    (117) func_call -> prepare_func_call . LPAREN arg_list RPAREN

    SEMICOLON       reduce using rule 100 (procedure_call -> prepare_func_call .)
    ELSE            reduce using rule 100 (procedure_call -> prepare_func_call .)
    LPAREN          shift and go to state 78


state 40

    (122) cond_if -> IF . condition THEN statement
    (123) cond_if -> IF . condition THEN statement ELSE statement
    (124) cond_if -> IF . condition THEN statement ELSE if_body
    (125) cond_if -> IF . condition THEN if_body
    (126) cond_if -> IF . condition THEN if_body ELSE if_body
    (127) cond_if -> IF . condition THEN if_body ELSE statement
    (128) condition -> . expressionGeneric
    (27) expressionGeneric -> . expression
    (28) expressionGeneric -> . expressionGeneric comparator expression
    (29) expression -> . term
    (30) expression -> . expression operationAdd term
    (31) term -> . fator
    (32) term -> . term operationMul fator
    (33) fator -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    condition                      shift and go to state 79
    expressionGeneric              shift and go to state 80
    expression                     shift and go to state 71
    term                           shift and go to state 72
    fator                          shift and go to state 73
    type                           shift and go to state 74
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 41

    (136) while_loop -> WHILE . condition DO statement
    (137) while_loop -> WHILE . condition DO if_body
    (128) condition -> . expressionGeneric
    (27) expressionGeneric -> . expression
    (28) expressionGeneric -> . expressionGeneric comparator expression
    (29) expression -> . term
    (30) expression -> . expression operationAdd term
    (31) term -> . fator
    (32) term -> . term operationMul fator
    (33) fator -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    condition                      shift and go to state 81
    expressionGeneric              shift and go to state 80
    expression                     shift and go to state 71
    term                           shift and go to state 72
    fator                          shift and go to state 73
    type                           shift and go to state 74
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 42

    (132) for_loop -> FOR . assignment to type DO statement
    (133) for_loop -> FOR . assignment to type DO if_body
    (134) for_loop -> FOR . assignment downto type DO statement
    (135) for_loop -> FOR . assignment downto type DO if_body
    (24) assignment -> . type ASSIGNMENT expressionGeneric
    (25) assignment -> . type ASSIGNMENT length
    (26) assignment -> . type ASSIGNMENT negation
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    assignment                     shift and go to state 82
    type                           shift and go to state 38
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 43

    (138) repeat_loop -> REPEAT . statements UNTIL condition
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (140) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT expressionGeneric
    (25) assignment -> . type ASSIGNMENT length
    (26) assignment -> . type ASSIGNMENT negation
    (100) procedure_call -> . prepare_func_call
    (101) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (122) cond_if -> . IF condition THEN statement
    (123) cond_if -> . IF condition THEN statement ELSE statement
    (124) cond_if -> . IF condition THEN statement ELSE if_body
    (125) cond_if -> . IF condition THEN if_body
    (126) cond_if -> . IF condition THEN if_body ELSE if_body
    (127) cond_if -> . IF condition THEN if_body ELSE statement
    (136) while_loop -> . WHILE condition DO statement
    (137) while_loop -> . WHILE condition DO if_body
    (132) for_loop -> . FOR assignment to type DO statement
    (133) for_loop -> . FOR assignment to type DO if_body
    (134) for_loop -> . FOR assignment downto type DO statement
    (135) for_loop -> . FOR assignment downto type DO if_body
    (138) repeat_loop -> . REPEAT statements UNTIL condition
    (139) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (118) prepare_func_call -> . IDENTIFIER
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN

    WRITELN         shift and go to state 36
    IF              shift and go to state 40
    WHILE           shift and go to state 41
    FOR             shift and go to state 42
    REPEAT          shift and go to state 43
    READLN          shift and go to state 44
    IDENTIFIER      shift and go to state 54
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    LPAREN          shift and go to state 37

    statements                     shift and go to state 83
    statement                      shift and go to state 27
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 38
    prepare_func_call              shift and go to state 39
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53

state 44

    (139) readln -> READLN . LPAREN type RPAREN

    LPAREN          shift and go to state 84


state 45

    (48) type -> integer .

    ASSIGNMENT      reduce using rule 48 (type -> integer .)
    TIMES           reduce using rule 48 (type -> integer .)
    DIVISION        reduce using rule 48 (type -> integer .)
    RANGE           reduce using rule 48 (type -> integer .)
    PLUS            reduce using rule 48 (type -> integer .)
    MINUS           reduce using rule 48 (type -> integer .)
    DIV             reduce using rule 48 (type -> integer .)
    MOD             reduce using rule 48 (type -> integer .)
    RPAREN          reduce using rule 48 (type -> integer .)
    EQ              reduce using rule 48 (type -> integer .)
    NEQ             reduce using rule 48 (type -> integer .)
    LT              reduce using rule 48 (type -> integer .)
    GT              reduce using rule 48 (type -> integer .)
    LTE             reduce using rule 48 (type -> integer .)
    GTE             reduce using rule 48 (type -> integer .)
    AND             reduce using rule 48 (type -> integer .)
    OR              reduce using rule 48 (type -> integer .)
    NOT             reduce using rule 48 (type -> integer .)
    THEN            reduce using rule 48 (type -> integer .)
    DO              reduce using rule 48 (type -> integer .)
    COMMA           reduce using rule 48 (type -> integer .)
    SEMICOLON       reduce using rule 48 (type -> integer .)
    TO              reduce using rule 48 (type -> integer .)
    DOWNTO          reduce using rule 48 (type -> integer .)
    ELSE            reduce using rule 48 (type -> integer .)
    RBRACKET        reduce using rule 48 (type -> integer .)


state 46

    (49) type -> real .

    ASSIGNMENT      reduce using rule 49 (type -> real .)
    TIMES           reduce using rule 49 (type -> real .)
    DIVISION        reduce using rule 49 (type -> real .)
    RANGE           reduce using rule 49 (type -> real .)
    PLUS            reduce using rule 49 (type -> real .)
    MINUS           reduce using rule 49 (type -> real .)
    DIV             reduce using rule 49 (type -> real .)
    MOD             reduce using rule 49 (type -> real .)
    RPAREN          reduce using rule 49 (type -> real .)
    EQ              reduce using rule 49 (type -> real .)
    NEQ             reduce using rule 49 (type -> real .)
    LT              reduce using rule 49 (type -> real .)
    GT              reduce using rule 49 (type -> real .)
    LTE             reduce using rule 49 (type -> real .)
    GTE             reduce using rule 49 (type -> real .)
    AND             reduce using rule 49 (type -> real .)
    OR              reduce using rule 49 (type -> real .)
    NOT             reduce using rule 49 (type -> real .)
    THEN            reduce using rule 49 (type -> real .)
    DO              reduce using rule 49 (type -> real .)
    COMMA           reduce using rule 49 (type -> real .)
    SEMICOLON       reduce using rule 49 (type -> real .)
    TO              reduce using rule 49 (type -> real .)
    DOWNTO          reduce using rule 49 (type -> real .)
    ELSE            reduce using rule 49 (type -> real .)
    RBRACKET        reduce using rule 49 (type -> real .)


state 47

    (50) type -> string .

    ASSIGNMENT      reduce using rule 50 (type -> string .)
    TIMES           reduce using rule 50 (type -> string .)
    DIVISION        reduce using rule 50 (type -> string .)
    RANGE           reduce using rule 50 (type -> string .)
    PLUS            reduce using rule 50 (type -> string .)
    MINUS           reduce using rule 50 (type -> string .)
    DIV             reduce using rule 50 (type -> string .)
    MOD             reduce using rule 50 (type -> string .)
    RPAREN          reduce using rule 50 (type -> string .)
    EQ              reduce using rule 50 (type -> string .)
    NEQ             reduce using rule 50 (type -> string .)
    LT              reduce using rule 50 (type -> string .)
    GT              reduce using rule 50 (type -> string .)
    LTE             reduce using rule 50 (type -> string .)
    GTE             reduce using rule 50 (type -> string .)
    AND             reduce using rule 50 (type -> string .)
    OR              reduce using rule 50 (type -> string .)
    NOT             reduce using rule 50 (type -> string .)
    THEN            reduce using rule 50 (type -> string .)
    DO              reduce using rule 50 (type -> string .)
    COMMA           reduce using rule 50 (type -> string .)
    SEMICOLON       reduce using rule 50 (type -> string .)
    TO              reduce using rule 50 (type -> string .)
    DOWNTO          reduce using rule 50 (type -> string .)
    ELSE            reduce using rule 50 (type -> string .)
    RBRACKET        reduce using rule 50 (type -> string .)


state 48

    (51) type -> char .

    ASSIGNMENT      reduce using rule 51 (type -> char .)
    TIMES           reduce using rule 51 (type -> char .)
    DIVISION        reduce using rule 51 (type -> char .)
    RANGE           reduce using rule 51 (type -> char .)
    PLUS            reduce using rule 51 (type -> char .)
    MINUS           reduce using rule 51 (type -> char .)
    DIV             reduce using rule 51 (type -> char .)
    MOD             reduce using rule 51 (type -> char .)
    RPAREN          reduce using rule 51 (type -> char .)
    EQ              reduce using rule 51 (type -> char .)
    NEQ             reduce using rule 51 (type -> char .)
    LT              reduce using rule 51 (type -> char .)
    GT              reduce using rule 51 (type -> char .)
    LTE             reduce using rule 51 (type -> char .)
    GTE             reduce using rule 51 (type -> char .)
    AND             reduce using rule 51 (type -> char .)
    OR              reduce using rule 51 (type -> char .)
    NOT             reduce using rule 51 (type -> char .)
    THEN            reduce using rule 51 (type -> char .)
    DO              reduce using rule 51 (type -> char .)
    COMMA           reduce using rule 51 (type -> char .)
    SEMICOLON       reduce using rule 51 (type -> char .)
    TO              reduce using rule 51 (type -> char .)
    DOWNTO          reduce using rule 51 (type -> char .)
    ELSE            reduce using rule 51 (type -> char .)
    RBRACKET        reduce using rule 51 (type -> char .)


state 49

    (52) type -> boolean .

    ASSIGNMENT      reduce using rule 52 (type -> boolean .)
    TIMES           reduce using rule 52 (type -> boolean .)
    DIVISION        reduce using rule 52 (type -> boolean .)
    RANGE           reduce using rule 52 (type -> boolean .)
    PLUS            reduce using rule 52 (type -> boolean .)
    MINUS           reduce using rule 52 (type -> boolean .)
    DIV             reduce using rule 52 (type -> boolean .)
    MOD             reduce using rule 52 (type -> boolean .)
    RPAREN          reduce using rule 52 (type -> boolean .)
    EQ              reduce using rule 52 (type -> boolean .)
    NEQ             reduce using rule 52 (type -> boolean .)
    LT              reduce using rule 52 (type -> boolean .)
    GT              reduce using rule 52 (type -> boolean .)
    LTE             reduce using rule 52 (type -> boolean .)
    GTE             reduce using rule 52 (type -> boolean .)
    AND             reduce using rule 52 (type -> boolean .)
    OR              reduce using rule 52 (type -> boolean .)
    NOT             reduce using rule 52 (type -> boolean .)
    THEN            reduce using rule 52 (type -> boolean .)
    DO              reduce using rule 52 (type -> boolean .)
    COMMA           reduce using rule 52 (type -> boolean .)
    SEMICOLON       reduce using rule 52 (type -> boolean .)
    TO              reduce using rule 52 (type -> boolean .)
    DOWNTO          reduce using rule 52 (type -> boolean .)
    ELSE            reduce using rule 52 (type -> boolean .)
    RBRACKET        reduce using rule 52 (type -> boolean .)


state 50

    (53) type -> identifier .

    ASSIGNMENT      reduce using rule 53 (type -> identifier .)
    TIMES           reduce using rule 53 (type -> identifier .)
    DIVISION        reduce using rule 53 (type -> identifier .)
    RANGE           reduce using rule 53 (type -> identifier .)
    PLUS            reduce using rule 53 (type -> identifier .)
    MINUS           reduce using rule 53 (type -> identifier .)
    DIV             reduce using rule 53 (type -> identifier .)
    MOD             reduce using rule 53 (type -> identifier .)
    RPAREN          reduce using rule 53 (type -> identifier .)
    EQ              reduce using rule 53 (type -> identifier .)
    NEQ             reduce using rule 53 (type -> identifier .)
    LT              reduce using rule 53 (type -> identifier .)
    GT              reduce using rule 53 (type -> identifier .)
    LTE             reduce using rule 53 (type -> identifier .)
    GTE             reduce using rule 53 (type -> identifier .)
    AND             reduce using rule 53 (type -> identifier .)
    OR              reduce using rule 53 (type -> identifier .)
    NOT             reduce using rule 53 (type -> identifier .)
    THEN            reduce using rule 53 (type -> identifier .)
    DO              reduce using rule 53 (type -> identifier .)
    COMMA           reduce using rule 53 (type -> identifier .)
    SEMICOLON       reduce using rule 53 (type -> identifier .)
    TO              reduce using rule 53 (type -> identifier .)
    DOWNTO          reduce using rule 53 (type -> identifier .)
    ELSE            reduce using rule 53 (type -> identifier .)
    RBRACKET        reduce using rule 53 (type -> identifier .)


state 51

    (54) type -> func_call .

    ASSIGNMENT      reduce using rule 54 (type -> func_call .)
    TIMES           reduce using rule 54 (type -> func_call .)
    DIVISION        reduce using rule 54 (type -> func_call .)
    RANGE           reduce using rule 54 (type -> func_call .)
    PLUS            reduce using rule 54 (type -> func_call .)
    MINUS           reduce using rule 54 (type -> func_call .)
    DIV             reduce using rule 54 (type -> func_call .)
    MOD             reduce using rule 54 (type -> func_call .)
    RPAREN          reduce using rule 54 (type -> func_call .)
    EQ              reduce using rule 54 (type -> func_call .)
    NEQ             reduce using rule 54 (type -> func_call .)
    LT              reduce using rule 54 (type -> func_call .)
    GT              reduce using rule 54 (type -> func_call .)
    LTE             reduce using rule 54 (type -> func_call .)
    GTE             reduce using rule 54 (type -> func_call .)
    AND             reduce using rule 54 (type -> func_call .)
    OR              reduce using rule 54 (type -> func_call .)
    NOT             reduce using rule 54 (type -> func_call .)
    THEN            reduce using rule 54 (type -> func_call .)
    DO              reduce using rule 54 (type -> func_call .)
    COMMA           reduce using rule 54 (type -> func_call .)
    SEMICOLON       reduce using rule 54 (type -> func_call .)
    TO              reduce using rule 54 (type -> func_call .)
    DOWNTO          reduce using rule 54 (type -> func_call .)
    ELSE            reduce using rule 54 (type -> func_call .)
    RBRACKET        reduce using rule 54 (type -> func_call .)


state 52

    (55) type -> array_access .

    ASSIGNMENT      reduce using rule 55 (type -> array_access .)
    TIMES           reduce using rule 55 (type -> array_access .)
    DIVISION        reduce using rule 55 (type -> array_access .)
    RANGE           reduce using rule 55 (type -> array_access .)
    PLUS            reduce using rule 55 (type -> array_access .)
    MINUS           reduce using rule 55 (type -> array_access .)
    DIV             reduce using rule 55 (type -> array_access .)
    MOD             reduce using rule 55 (type -> array_access .)
    RPAREN          reduce using rule 55 (type -> array_access .)
    EQ              reduce using rule 55 (type -> array_access .)
    NEQ             reduce using rule 55 (type -> array_access .)
    LT              reduce using rule 55 (type -> array_access .)
    GT              reduce using rule 55 (type -> array_access .)
    LTE             reduce using rule 55 (type -> array_access .)
    GTE             reduce using rule 55 (type -> array_access .)
    AND             reduce using rule 55 (type -> array_access .)
    OR              reduce using rule 55 (type -> array_access .)
    NOT             reduce using rule 55 (type -> array_access .)
    THEN            reduce using rule 55 (type -> array_access .)
    DO              reduce using rule 55 (type -> array_access .)
    COMMA           reduce using rule 55 (type -> array_access .)
    SEMICOLON       reduce using rule 55 (type -> array_access .)
    TO              reduce using rule 55 (type -> array_access .)
    DOWNTO          reduce using rule 55 (type -> array_access .)
    ELSE            reduce using rule 55 (type -> array_access .)
    RBRACKET        reduce using rule 55 (type -> array_access .)


state 53

    (56) type -> expression_paren .

    ASSIGNMENT      reduce using rule 56 (type -> expression_paren .)
    TIMES           reduce using rule 56 (type -> expression_paren .)
    DIVISION        reduce using rule 56 (type -> expression_paren .)
    RANGE           reduce using rule 56 (type -> expression_paren .)
    PLUS            reduce using rule 56 (type -> expression_paren .)
    MINUS           reduce using rule 56 (type -> expression_paren .)
    DIV             reduce using rule 56 (type -> expression_paren .)
    MOD             reduce using rule 56 (type -> expression_paren .)
    RPAREN          reduce using rule 56 (type -> expression_paren .)
    EQ              reduce using rule 56 (type -> expression_paren .)
    NEQ             reduce using rule 56 (type -> expression_paren .)
    LT              reduce using rule 56 (type -> expression_paren .)
    GT              reduce using rule 56 (type -> expression_paren .)
    LTE             reduce using rule 56 (type -> expression_paren .)
    GTE             reduce using rule 56 (type -> expression_paren .)
    AND             reduce using rule 56 (type -> expression_paren .)
    OR              reduce using rule 56 (type -> expression_paren .)
    NOT             reduce using rule 56 (type -> expression_paren .)
    THEN            reduce using rule 56 (type -> expression_paren .)
    DO              reduce using rule 56 (type -> expression_paren .)
    COMMA           reduce using rule 56 (type -> expression_paren .)
    SEMICOLON       reduce using rule 56 (type -> expression_paren .)
    TO              reduce using rule 56 (type -> expression_paren .)
    DOWNTO          reduce using rule 56 (type -> expression_paren .)
    ELSE            reduce using rule 56 (type -> expression_paren .)
    RBRACKET        reduce using rule 56 (type -> expression_paren .)


state 54

    (118) prepare_func_call -> IDENTIFIER .
    (62) identifier -> IDENTIFIER .
    (12) array_access -> IDENTIFIER . LBRACKET expressionGeneric RBRACKET

    LPAREN          reduce using rule 118 (prepare_func_call -> IDENTIFIER .)
    SEMICOLON       reduce using rule 118 (prepare_func_call -> IDENTIFIER .)
    ELSE            reduce using rule 118 (prepare_func_call -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 62 (identifier -> IDENTIFIER .)
    LBRACKET        shift and go to state 85


state 55

    (57) integer -> INTEGER .

    ASSIGNMENT      reduce using rule 57 (integer -> INTEGER .)
    TIMES           reduce using rule 57 (integer -> INTEGER .)
    DIVISION        reduce using rule 57 (integer -> INTEGER .)
    RANGE           reduce using rule 57 (integer -> INTEGER .)
    PLUS            reduce using rule 57 (integer -> INTEGER .)
    MINUS           reduce using rule 57 (integer -> INTEGER .)
    DIV             reduce using rule 57 (integer -> INTEGER .)
    MOD             reduce using rule 57 (integer -> INTEGER .)
    RPAREN          reduce using rule 57 (integer -> INTEGER .)
    EQ              reduce using rule 57 (integer -> INTEGER .)
    NEQ             reduce using rule 57 (integer -> INTEGER .)
    LT              reduce using rule 57 (integer -> INTEGER .)
    GT              reduce using rule 57 (integer -> INTEGER .)
    LTE             reduce using rule 57 (integer -> INTEGER .)
    GTE             reduce using rule 57 (integer -> INTEGER .)
    AND             reduce using rule 57 (integer -> INTEGER .)
    OR              reduce using rule 57 (integer -> INTEGER .)
    NOT             reduce using rule 57 (integer -> INTEGER .)
    THEN            reduce using rule 57 (integer -> INTEGER .)
    DO              reduce using rule 57 (integer -> INTEGER .)
    COMMA           reduce using rule 57 (integer -> INTEGER .)
    SEMICOLON       reduce using rule 57 (integer -> INTEGER .)
    TO              reduce using rule 57 (integer -> INTEGER .)
    DOWNTO          reduce using rule 57 (integer -> INTEGER .)
    ELSE            reduce using rule 57 (integer -> INTEGER .)
    RBRACKET        reduce using rule 57 (integer -> INTEGER .)


state 56

    (58) real -> REAL .

    ASSIGNMENT      reduce using rule 58 (real -> REAL .)
    TIMES           reduce using rule 58 (real -> REAL .)
    DIVISION        reduce using rule 58 (real -> REAL .)
    RANGE           reduce using rule 58 (real -> REAL .)
    PLUS            reduce using rule 58 (real -> REAL .)
    MINUS           reduce using rule 58 (real -> REAL .)
    DIV             reduce using rule 58 (real -> REAL .)
    MOD             reduce using rule 58 (real -> REAL .)
    RPAREN          reduce using rule 58 (real -> REAL .)
    EQ              reduce using rule 58 (real -> REAL .)
    NEQ             reduce using rule 58 (real -> REAL .)
    LT              reduce using rule 58 (real -> REAL .)
    GT              reduce using rule 58 (real -> REAL .)
    LTE             reduce using rule 58 (real -> REAL .)
    GTE             reduce using rule 58 (real -> REAL .)
    AND             reduce using rule 58 (real -> REAL .)
    OR              reduce using rule 58 (real -> REAL .)
    NOT             reduce using rule 58 (real -> REAL .)
    THEN            reduce using rule 58 (real -> REAL .)
    DO              reduce using rule 58 (real -> REAL .)
    COMMA           reduce using rule 58 (real -> REAL .)
    SEMICOLON       reduce using rule 58 (real -> REAL .)
    TO              reduce using rule 58 (real -> REAL .)
    DOWNTO          reduce using rule 58 (real -> REAL .)
    ELSE            reduce using rule 58 (real -> REAL .)
    RBRACKET        reduce using rule 58 (real -> REAL .)


state 57

    (59) string -> STRING .

    ASSIGNMENT      reduce using rule 59 (string -> STRING .)
    TIMES           reduce using rule 59 (string -> STRING .)
    DIVISION        reduce using rule 59 (string -> STRING .)
    RANGE           reduce using rule 59 (string -> STRING .)
    PLUS            reduce using rule 59 (string -> STRING .)
    MINUS           reduce using rule 59 (string -> STRING .)
    DIV             reduce using rule 59 (string -> STRING .)
    MOD             reduce using rule 59 (string -> STRING .)
    RPAREN          reduce using rule 59 (string -> STRING .)
    EQ              reduce using rule 59 (string -> STRING .)
    NEQ             reduce using rule 59 (string -> STRING .)
    LT              reduce using rule 59 (string -> STRING .)
    GT              reduce using rule 59 (string -> STRING .)
    LTE             reduce using rule 59 (string -> STRING .)
    GTE             reduce using rule 59 (string -> STRING .)
    AND             reduce using rule 59 (string -> STRING .)
    OR              reduce using rule 59 (string -> STRING .)
    NOT             reduce using rule 59 (string -> STRING .)
    THEN            reduce using rule 59 (string -> STRING .)
    DO              reduce using rule 59 (string -> STRING .)
    COMMA           reduce using rule 59 (string -> STRING .)
    SEMICOLON       reduce using rule 59 (string -> STRING .)
    TO              reduce using rule 59 (string -> STRING .)
    DOWNTO          reduce using rule 59 (string -> STRING .)
    ELSE            reduce using rule 59 (string -> STRING .)
    RBRACKET        reduce using rule 59 (string -> STRING .)


state 58

    (60) char -> CHAR .

    ASSIGNMENT      reduce using rule 60 (char -> CHAR .)
    TIMES           reduce using rule 60 (char -> CHAR .)
    DIVISION        reduce using rule 60 (char -> CHAR .)
    RANGE           reduce using rule 60 (char -> CHAR .)
    PLUS            reduce using rule 60 (char -> CHAR .)
    MINUS           reduce using rule 60 (char -> CHAR .)
    DIV             reduce using rule 60 (char -> CHAR .)
    MOD             reduce using rule 60 (char -> CHAR .)
    RPAREN          reduce using rule 60 (char -> CHAR .)
    EQ              reduce using rule 60 (char -> CHAR .)
    NEQ             reduce using rule 60 (char -> CHAR .)
    LT              reduce using rule 60 (char -> CHAR .)
    GT              reduce using rule 60 (char -> CHAR .)
    LTE             reduce using rule 60 (char -> CHAR .)
    GTE             reduce using rule 60 (char -> CHAR .)
    AND             reduce using rule 60 (char -> CHAR .)
    OR              reduce using rule 60 (char -> CHAR .)
    NOT             reduce using rule 60 (char -> CHAR .)
    THEN            reduce using rule 60 (char -> CHAR .)
    DO              reduce using rule 60 (char -> CHAR .)
    COMMA           reduce using rule 60 (char -> CHAR .)
    SEMICOLON       reduce using rule 60 (char -> CHAR .)
    TO              reduce using rule 60 (char -> CHAR .)
    DOWNTO          reduce using rule 60 (char -> CHAR .)
    ELSE            reduce using rule 60 (char -> CHAR .)
    RBRACKET        reduce using rule 60 (char -> CHAR .)


state 59

    (61) boolean -> BOOLEAN .

    ASSIGNMENT      reduce using rule 61 (boolean -> BOOLEAN .)
    TIMES           reduce using rule 61 (boolean -> BOOLEAN .)
    DIVISION        reduce using rule 61 (boolean -> BOOLEAN .)
    RANGE           reduce using rule 61 (boolean -> BOOLEAN .)
    PLUS            reduce using rule 61 (boolean -> BOOLEAN .)
    MINUS           reduce using rule 61 (boolean -> BOOLEAN .)
    DIV             reduce using rule 61 (boolean -> BOOLEAN .)
    MOD             reduce using rule 61 (boolean -> BOOLEAN .)
    RPAREN          reduce using rule 61 (boolean -> BOOLEAN .)
    EQ              reduce using rule 61 (boolean -> BOOLEAN .)
    NEQ             reduce using rule 61 (boolean -> BOOLEAN .)
    LT              reduce using rule 61 (boolean -> BOOLEAN .)
    GT              reduce using rule 61 (boolean -> BOOLEAN .)
    LTE             reduce using rule 61 (boolean -> BOOLEAN .)
    GTE             reduce using rule 61 (boolean -> BOOLEAN .)
    AND             reduce using rule 61 (boolean -> BOOLEAN .)
    OR              reduce using rule 61 (boolean -> BOOLEAN .)
    NOT             reduce using rule 61 (boolean -> BOOLEAN .)
    THEN            reduce using rule 61 (boolean -> BOOLEAN .)
    DO              reduce using rule 61 (boolean -> BOOLEAN .)
    COMMA           reduce using rule 61 (boolean -> BOOLEAN .)
    SEMICOLON       reduce using rule 61 (boolean -> BOOLEAN .)
    TO              reduce using rule 61 (boolean -> BOOLEAN .)
    DOWNTO          reduce using rule 61 (boolean -> BOOLEAN .)
    ELSE            reduce using rule 61 (boolean -> BOOLEAN .)
    RBRACKET        reduce using rule 61 (boolean -> BOOLEAN .)


state 60

    (107) function_with_vars -> func_header SEMICOLON . VAR func_variable_declaration func_body SEMICOLON
    (108) function_with_no_vars -> func_header SEMICOLON . func_body SEMICOLON
    (116) func_body -> . BEGIN statements END

    VAR             shift and go to state 86
    BEGIN           shift and go to state 88

    func_body                      shift and go to state 87

state 61

    (93) procedure_no_args_no_vars -> PROCEDURE IDENTIFIER . SEMICOLON procedure_body SEMICOLON
    (94) procedure_args_no_vars -> PROCEDURE IDENTIFIER . LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (95) procedure_no_args_vars -> PROCEDURE IDENTIFIER . SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (96) procedure_args_vars -> PROCEDURE IDENTIFIER . LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON

    SEMICOLON       shift and go to state 89
    LPAREN          shift and go to state 90


state 62

    (109) func_header -> FUNCTION IDENTIFIER . LPAREN func_args RPAREN COLON type_name
    (110) func_header -> FUNCTION IDENTIFIER . LPAREN RPAREN COLON type_name

    LPAREN          shift and go to state 91


state 63

    (2) header -> PROGRAM IDENTIFIER SEMICOLON .

    VAR             reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    BEGIN           reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    PROCEDURE       reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)
    FUNCTION        reduce using rule 2 (header -> PROGRAM IDENTIFIER SEMICOLON .)


state 64

    (3) block -> VAR variable_declaration body .

    DOT             reduce using rule 3 (block -> VAR variable_declaration body .)


state 65

    (7) variable_declaration -> identifier_list COLON . type_name SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list COLON . type_name SEMICOLON
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 93
    NREAL           shift and go to state 94
    NSTRING         shift and go to state 95
    NCHAR           shift and go to state 96
    NBOOLEAN        shift and go to state 97
    ARRAY           shift and go to state 99

    type_name                      shift and go to state 92
    array_type                     shift and go to state 98

state 66

    (9) identifier_list -> IDENTIFIER COMMA . identifier_list
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 23

    identifier_list                shift and go to state 100

state 67

    (13) body -> BEGIN statements END .

    DOT             reduce using rule 13 (body -> BEGIN statements END .)


state 68

    (14) statements -> statement SEMICOLON . statements
    (15) statements -> statement SEMICOLON .
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (140) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT expressionGeneric
    (25) assignment -> . type ASSIGNMENT length
    (26) assignment -> . type ASSIGNMENT negation
    (100) procedure_call -> . prepare_func_call
    (101) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (122) cond_if -> . IF condition THEN statement
    (123) cond_if -> . IF condition THEN statement ELSE statement
    (124) cond_if -> . IF condition THEN statement ELSE if_body
    (125) cond_if -> . IF condition THEN if_body
    (126) cond_if -> . IF condition THEN if_body ELSE if_body
    (127) cond_if -> . IF condition THEN if_body ELSE statement
    (136) while_loop -> . WHILE condition DO statement
    (137) while_loop -> . WHILE condition DO if_body
    (132) for_loop -> . FOR assignment to type DO statement
    (133) for_loop -> . FOR assignment to type DO if_body
    (134) for_loop -> . FOR assignment downto type DO statement
    (135) for_loop -> . FOR assignment downto type DO if_body
    (138) repeat_loop -> . REPEAT statements UNTIL condition
    (139) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (118) prepare_func_call -> . IDENTIFIER
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN

    END             reduce using rule 15 (statements -> statement SEMICOLON .)
    UNTIL           reduce using rule 15 (statements -> statement SEMICOLON .)
    WRITELN         shift and go to state 36
    IF              shift and go to state 40
    WHILE           shift and go to state 41
    FOR             shift and go to state 42
    REPEAT          shift and go to state 43
    READLN          shift and go to state 44
    IDENTIFIER      shift and go to state 54
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    LPAREN          shift and go to state 37

    statement                      shift and go to state 27
    statements                     shift and go to state 101
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 38
    prepare_func_call              shift and go to state 39
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53

state 69

    (140) writeln -> WRITELN LPAREN . writeln_args RPAREN
    (141) writeln_args -> . type COMMA writeln_args
    (142) writeln_args -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    writeln_args                   shift and go to state 102
    type                           shift and go to state 103
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 70

    (34) expression_paren -> LPAREN expressionGeneric . RPAREN
    (28) expressionGeneric -> expressionGeneric . comparator expression
    (69) comparator -> . eq
    (70) comparator -> . neq
    (71) comparator -> . lt
    (72) comparator -> . gt
    (73) comparator -> . lte
    (74) comparator -> . gte
    (75) comparator -> . and
    (76) comparator -> . or
    (77) comparator -> . not
    (78) eq -> . EQ
    (79) neq -> . NEQ
    (80) lt -> . LT
    (81) gt -> . GT
    (82) lte -> . LTE
    (83) gte -> . GTE
    (84) and -> . AND
    (85) or -> . OR
    (86) not -> . NOT

    RPAREN          shift and go to state 104
    EQ              shift and go to state 115
    NEQ             shift and go to state 116
    LT              shift and go to state 117
    GT              shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    AND             shift and go to state 121
    OR              shift and go to state 122
    NOT             shift and go to state 123

    comparator                     shift and go to state 105
    eq                             shift and go to state 106
    neq                            shift and go to state 107
    lt                             shift and go to state 108
    gt                             shift and go to state 109
    lte                            shift and go to state 110
    gte                            shift and go to state 111
    and                            shift and go to state 112
    or                             shift and go to state 113
    not                            shift and go to state 114

state 71

    (27) expressionGeneric -> expression .
    (30) expression -> expression . operationAdd term
    (35) operationAdd -> . plus
    (36) operationAdd -> . minus
    (37) operationAdd -> . div
    (38) operationAdd -> . mod
    (39) operationAdd -> . RANGE
    (63) plus -> . PLUS
    (64) minus -> . MINUS
    (67) div -> . DIV
    (68) mod -> . MOD

    RPAREN          reduce using rule 27 (expressionGeneric -> expression .)
    EQ              reduce using rule 27 (expressionGeneric -> expression .)
    NEQ             reduce using rule 27 (expressionGeneric -> expression .)
    LT              reduce using rule 27 (expressionGeneric -> expression .)
    GT              reduce using rule 27 (expressionGeneric -> expression .)
    LTE             reduce using rule 27 (expressionGeneric -> expression .)
    GTE             reduce using rule 27 (expressionGeneric -> expression .)
    AND             reduce using rule 27 (expressionGeneric -> expression .)
    OR              reduce using rule 27 (expressionGeneric -> expression .)
    NOT             reduce using rule 27 (expressionGeneric -> expression .)
    THEN            reduce using rule 27 (expressionGeneric -> expression .)
    DO              reduce using rule 27 (expressionGeneric -> expression .)
    SEMICOLON       reduce using rule 27 (expressionGeneric -> expression .)
    TO              reduce using rule 27 (expressionGeneric -> expression .)
    DOWNTO          reduce using rule 27 (expressionGeneric -> expression .)
    ELSE            reduce using rule 27 (expressionGeneric -> expression .)
    COMMA           reduce using rule 27 (expressionGeneric -> expression .)
    RBRACKET        reduce using rule 27 (expressionGeneric -> expression .)
    RANGE           shift and go to state 129
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    DIV             shift and go to state 132
    MOD             shift and go to state 133

    operationAdd                   shift and go to state 124
    plus                           shift and go to state 125
    minus                          shift and go to state 126
    div                            shift and go to state 127
    mod                            shift and go to state 128

state 72

    (29) expression -> term .
    (32) term -> term . operationMul fator
    (40) operationMul -> . times
    (41) operationMul -> . division
    (65) times -> . TIMES
    (66) division -> . DIVISION

    RANGE           reduce using rule 29 (expression -> term .)
    PLUS            reduce using rule 29 (expression -> term .)
    MINUS           reduce using rule 29 (expression -> term .)
    DIV             reduce using rule 29 (expression -> term .)
    MOD             reduce using rule 29 (expression -> term .)
    RPAREN          reduce using rule 29 (expression -> term .)
    EQ              reduce using rule 29 (expression -> term .)
    NEQ             reduce using rule 29 (expression -> term .)
    LT              reduce using rule 29 (expression -> term .)
    GT              reduce using rule 29 (expression -> term .)
    LTE             reduce using rule 29 (expression -> term .)
    GTE             reduce using rule 29 (expression -> term .)
    AND             reduce using rule 29 (expression -> term .)
    OR              reduce using rule 29 (expression -> term .)
    NOT             reduce using rule 29 (expression -> term .)
    THEN            reduce using rule 29 (expression -> term .)
    DO              reduce using rule 29 (expression -> term .)
    SEMICOLON       reduce using rule 29 (expression -> term .)
    TO              reduce using rule 29 (expression -> term .)
    DOWNTO          reduce using rule 29 (expression -> term .)
    ELSE            reduce using rule 29 (expression -> term .)
    COMMA           reduce using rule 29 (expression -> term .)
    RBRACKET        reduce using rule 29 (expression -> term .)
    TIMES           shift and go to state 137
    DIVISION        shift and go to state 138

    operationMul                   shift and go to state 134
    times                          shift and go to state 135
    division                       shift and go to state 136

state 73

    (31) term -> fator .

    TIMES           reduce using rule 31 (term -> fator .)
    DIVISION        reduce using rule 31 (term -> fator .)
    RANGE           reduce using rule 31 (term -> fator .)
    PLUS            reduce using rule 31 (term -> fator .)
    MINUS           reduce using rule 31 (term -> fator .)
    DIV             reduce using rule 31 (term -> fator .)
    MOD             reduce using rule 31 (term -> fator .)
    RPAREN          reduce using rule 31 (term -> fator .)
    EQ              reduce using rule 31 (term -> fator .)
    NEQ             reduce using rule 31 (term -> fator .)
    LT              reduce using rule 31 (term -> fator .)
    GT              reduce using rule 31 (term -> fator .)
    LTE             reduce using rule 31 (term -> fator .)
    GTE             reduce using rule 31 (term -> fator .)
    AND             reduce using rule 31 (term -> fator .)
    OR              reduce using rule 31 (term -> fator .)
    NOT             reduce using rule 31 (term -> fator .)
    THEN            reduce using rule 31 (term -> fator .)
    DO              reduce using rule 31 (term -> fator .)
    SEMICOLON       reduce using rule 31 (term -> fator .)
    TO              reduce using rule 31 (term -> fator .)
    DOWNTO          reduce using rule 31 (term -> fator .)
    ELSE            reduce using rule 31 (term -> fator .)
    COMMA           reduce using rule 31 (term -> fator .)
    RBRACKET        reduce using rule 31 (term -> fator .)


state 74

    (33) fator -> type .

    TIMES           reduce using rule 33 (fator -> type .)
    DIVISION        reduce using rule 33 (fator -> type .)
    RANGE           reduce using rule 33 (fator -> type .)
    PLUS            reduce using rule 33 (fator -> type .)
    MINUS           reduce using rule 33 (fator -> type .)
    DIV             reduce using rule 33 (fator -> type .)
    MOD             reduce using rule 33 (fator -> type .)
    RPAREN          reduce using rule 33 (fator -> type .)
    EQ              reduce using rule 33 (fator -> type .)
    NEQ             reduce using rule 33 (fator -> type .)
    LT              reduce using rule 33 (fator -> type .)
    GT              reduce using rule 33 (fator -> type .)
    LTE             reduce using rule 33 (fator -> type .)
    GTE             reduce using rule 33 (fator -> type .)
    AND             reduce using rule 33 (fator -> type .)
    OR              reduce using rule 33 (fator -> type .)
    NOT             reduce using rule 33 (fator -> type .)
    THEN            reduce using rule 33 (fator -> type .)
    DO              reduce using rule 33 (fator -> type .)
    SEMICOLON       reduce using rule 33 (fator -> type .)
    TO              reduce using rule 33 (fator -> type .)
    DOWNTO          reduce using rule 33 (fator -> type .)
    ELSE            reduce using rule 33 (fator -> type .)
    COMMA           reduce using rule 33 (fator -> type .)
    RBRACKET        reduce using rule 33 (fator -> type .)


state 75

    (62) identifier -> IDENTIFIER .
    (12) array_access -> IDENTIFIER . LBRACKET expressionGeneric RBRACKET
    (118) prepare_func_call -> IDENTIFIER .

    TIMES           reduce using rule 62 (identifier -> IDENTIFIER .)
    DIVISION        reduce using rule 62 (identifier -> IDENTIFIER .)
    RANGE           reduce using rule 62 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 62 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 62 (identifier -> IDENTIFIER .)
    DIV             reduce using rule 62 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 62 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 62 (identifier -> IDENTIFIER .)
    EQ              reduce using rule 62 (identifier -> IDENTIFIER .)
    NEQ             reduce using rule 62 (identifier -> IDENTIFIER .)
    LT              reduce using rule 62 (identifier -> IDENTIFIER .)
    GT              reduce using rule 62 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 62 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 62 (identifier -> IDENTIFIER .)
    AND             reduce using rule 62 (identifier -> IDENTIFIER .)
    OR              reduce using rule 62 (identifier -> IDENTIFIER .)
    NOT             reduce using rule 62 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 62 (identifier -> IDENTIFIER .)
    DO              reduce using rule 62 (identifier -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 62 (identifier -> IDENTIFIER .)
    COMMA           reduce using rule 62 (identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 62 (identifier -> IDENTIFIER .)
    TO              reduce using rule 62 (identifier -> IDENTIFIER .)
    DOWNTO          reduce using rule 62 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 62 (identifier -> IDENTIFIER .)
    RBRACKET        reduce using rule 62 (identifier -> IDENTIFIER .)
    LBRACKET        shift and go to state 85
    LPAREN          reduce using rule 118 (prepare_func_call -> IDENTIFIER .)


state 76

    (117) func_call -> prepare_func_call . LPAREN arg_list RPAREN

    LPAREN          shift and go to state 139


state 77

    (24) assignment -> type ASSIGNMENT . expressionGeneric
    (25) assignment -> type ASSIGNMENT . length
    (26) assignment -> type ASSIGNMENT . negation
    (27) expressionGeneric -> . expression
    (28) expressionGeneric -> . expressionGeneric comparator expression
    (104) length -> . LENGTH LPAREN type RPAREN
    (87) negation -> . not boolean
    (88) negation -> . not func_call
    (29) expression -> . term
    (30) expression -> . expression operationAdd term
    (86) not -> . NOT
    (31) term -> . fator
    (32) term -> . term operationMul fator
    (33) fator -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    LENGTH          shift and go to state 143
    NOT             shift and go to state 123
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    type                           shift and go to state 74
    expressionGeneric              shift and go to state 140
    length                         shift and go to state 141
    negation                       shift and go to state 142
    expression                     shift and go to state 71
    not                            shift and go to state 144
    boolean                        shift and go to state 49
    func_call                      shift and go to state 51
    term                           shift and go to state 72
    fator                          shift and go to state 73
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    identifier                     shift and go to state 50
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 78

    (101) procedure_call -> prepare_func_call LPAREN . procedure_arg_list RPAREN
    (117) func_call -> prepare_func_call LPAREN . arg_list RPAREN
    (102) procedure_arg_list -> . expressionGeneric COMMA procedure_arg_list
    (103) procedure_arg_list -> . expressionGeneric
    (119) arg_list -> . expressionGeneric COMMA arg_list
    (120) arg_list -> . expressionGeneric
    (121) arg_list -> .
    (27) expressionGeneric -> . expression
    (28) expressionGeneric -> . expressionGeneric comparator expression
    (29) expression -> . term
    (30) expression -> . expression operationAdd term
    (31) term -> . fator
    (32) term -> . term operationMul fator
    (33) fator -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    RPAREN          reduce using rule 121 (arg_list -> .)
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    prepare_func_call              shift and go to state 76
    procedure_arg_list             shift and go to state 145
    arg_list                       shift and go to state 146
    expressionGeneric              shift and go to state 147
    expression                     shift and go to state 71
    term                           shift and go to state 72
    fator                          shift and go to state 73
    type                           shift and go to state 74
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53

state 79

    (122) cond_if -> IF condition . THEN statement
    (123) cond_if -> IF condition . THEN statement ELSE statement
    (124) cond_if -> IF condition . THEN statement ELSE if_body
    (125) cond_if -> IF condition . THEN if_body
    (126) cond_if -> IF condition . THEN if_body ELSE if_body
    (127) cond_if -> IF condition . THEN if_body ELSE statement

    THEN            shift and go to state 148


state 80

    (128) condition -> expressionGeneric .
    (28) expressionGeneric -> expressionGeneric . comparator expression
    (69) comparator -> . eq
    (70) comparator -> . neq
    (71) comparator -> . lt
    (72) comparator -> . gt
    (73) comparator -> . lte
    (74) comparator -> . gte
    (75) comparator -> . and
    (76) comparator -> . or
    (77) comparator -> . not
    (78) eq -> . EQ
    (79) neq -> . NEQ
    (80) lt -> . LT
    (81) gt -> . GT
    (82) lte -> . LTE
    (83) gte -> . GTE
    (84) and -> . AND
    (85) or -> . OR
    (86) not -> . NOT

    THEN            reduce using rule 128 (condition -> expressionGeneric .)
    DO              reduce using rule 128 (condition -> expressionGeneric .)
    SEMICOLON       reduce using rule 128 (condition -> expressionGeneric .)
    ELSE            reduce using rule 128 (condition -> expressionGeneric .)
    EQ              shift and go to state 115
    NEQ             shift and go to state 116
    LT              shift and go to state 117
    GT              shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    AND             shift and go to state 121
    OR              shift and go to state 122
    NOT             shift and go to state 123

    comparator                     shift and go to state 105
    eq                             shift and go to state 106
    neq                            shift and go to state 107
    lt                             shift and go to state 108
    gt                             shift and go to state 109
    lte                            shift and go to state 110
    gte                            shift and go to state 111
    and                            shift and go to state 112
    or                             shift and go to state 113
    not                            shift and go to state 114

state 81

    (136) while_loop -> WHILE condition . DO statement
    (137) while_loop -> WHILE condition . DO if_body

    DO              shift and go to state 149


state 82

    (132) for_loop -> FOR assignment . to type DO statement
    (133) for_loop -> FOR assignment . to type DO if_body
    (134) for_loop -> FOR assignment . downto type DO statement
    (135) for_loop -> FOR assignment . downto type DO if_body
    (130) to -> . TO
    (131) downto -> . DOWNTO

    TO              shift and go to state 152
    DOWNTO          shift and go to state 153

    to                             shift and go to state 150
    downto                         shift and go to state 151

state 83

    (138) repeat_loop -> REPEAT statements . UNTIL condition

    UNTIL           shift and go to state 154


state 84

    (139) readln -> READLN LPAREN . type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    type                           shift and go to state 155
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 85

    (12) array_access -> IDENTIFIER LBRACKET . expressionGeneric RBRACKET
    (27) expressionGeneric -> . expression
    (28) expressionGeneric -> . expressionGeneric comparator expression
    (29) expression -> . term
    (30) expression -> . expression operationAdd term
    (31) term -> . fator
    (32) term -> . term operationMul fator
    (33) fator -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    expressionGeneric              shift and go to state 156
    expression                     shift and go to state 71
    term                           shift and go to state 72
    fator                          shift and go to state 73
    type                           shift and go to state 74
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 86

    (107) function_with_vars -> func_header SEMICOLON VAR . func_variable_declaration func_body SEMICOLON
    (114) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON func_variable_declaration
    (115) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 23

    func_variable_declaration      shift and go to state 157
    identifier_list                shift and go to state 158

state 87

    (108) function_with_no_vars -> func_header SEMICOLON func_body . SEMICOLON

    SEMICOLON       shift and go to state 159


state 88

    (116) func_body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (140) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT expressionGeneric
    (25) assignment -> . type ASSIGNMENT length
    (26) assignment -> . type ASSIGNMENT negation
    (100) procedure_call -> . prepare_func_call
    (101) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (122) cond_if -> . IF condition THEN statement
    (123) cond_if -> . IF condition THEN statement ELSE statement
    (124) cond_if -> . IF condition THEN statement ELSE if_body
    (125) cond_if -> . IF condition THEN if_body
    (126) cond_if -> . IF condition THEN if_body ELSE if_body
    (127) cond_if -> . IF condition THEN if_body ELSE statement
    (136) while_loop -> . WHILE condition DO statement
    (137) while_loop -> . WHILE condition DO if_body
    (132) for_loop -> . FOR assignment to type DO statement
    (133) for_loop -> . FOR assignment to type DO if_body
    (134) for_loop -> . FOR assignment downto type DO statement
    (135) for_loop -> . FOR assignment downto type DO if_body
    (138) repeat_loop -> . REPEAT statements UNTIL condition
    (139) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (118) prepare_func_call -> . IDENTIFIER
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN

    WRITELN         shift and go to state 36
    IF              shift and go to state 40
    WHILE           shift and go to state 41
    FOR             shift and go to state 42
    REPEAT          shift and go to state 43
    READLN          shift and go to state 44
    IDENTIFIER      shift and go to state 54
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    LPAREN          shift and go to state 37

    statements                     shift and go to state 160
    statement                      shift and go to state 27
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 38
    prepare_func_call              shift and go to state 39
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53

state 89

    (93) procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON . procedure_body SEMICOLON
    (95) procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON . VAR func_variable_declaration procedure_body SEMICOLON
    (99) procedure_body -> . BEGIN statements END

    VAR             shift and go to state 162
    BEGIN           shift and go to state 163

    procedure_body                 shift and go to state 161

state 90

    (94) procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN . func_args RPAREN SEMICOLON procedure_body SEMICOLON
    (96) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN . func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON
    (111) func_args -> . func_arglist SEMICOLON func_args
    (112) func_args -> . func_arglist
    (113) func_arglist -> . identifier_list COLON type_name
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 23

    func_args                      shift and go to state 164
    func_arglist                   shift and go to state 165
    identifier_list                shift and go to state 166

state 91

    (109) func_header -> FUNCTION IDENTIFIER LPAREN . func_args RPAREN COLON type_name
    (110) func_header -> FUNCTION IDENTIFIER LPAREN . RPAREN COLON type_name
    (111) func_args -> . func_arglist SEMICOLON func_args
    (112) func_args -> . func_arglist
    (113) func_arglist -> . identifier_list COLON type_name
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    RPAREN          shift and go to state 168
    IDENTIFIER      shift and go to state 23

    func_args                      shift and go to state 167
    func_arglist                   shift and go to state 165
    identifier_list                shift and go to state 166

state 92

    (7) variable_declaration -> identifier_list COLON type_name . SEMICOLON variable_declaration
    (8) variable_declaration -> identifier_list COLON type_name . SEMICOLON

    SEMICOLON       shift and go to state 169


state 93

    (42) type_name -> NINTEGER .

    SEMICOLON       reduce using rule 42 (type_name -> NINTEGER .)
    RPAREN          reduce using rule 42 (type_name -> NINTEGER .)


state 94

    (43) type_name -> NREAL .

    SEMICOLON       reduce using rule 43 (type_name -> NREAL .)
    RPAREN          reduce using rule 43 (type_name -> NREAL .)


state 95

    (44) type_name -> NSTRING .

    SEMICOLON       reduce using rule 44 (type_name -> NSTRING .)
    RPAREN          reduce using rule 44 (type_name -> NSTRING .)


state 96

    (45) type_name -> NCHAR .

    SEMICOLON       reduce using rule 45 (type_name -> NCHAR .)
    RPAREN          reduce using rule 45 (type_name -> NCHAR .)


state 97

    (46) type_name -> NBOOLEAN .

    SEMICOLON       reduce using rule 46 (type_name -> NBOOLEAN .)
    RPAREN          reduce using rule 46 (type_name -> NBOOLEAN .)


state 98

    (47) type_name -> array_type .

    SEMICOLON       reduce using rule 47 (type_name -> array_type .)
    RPAREN          reduce using rule 47 (type_name -> array_type .)


state 99

    (11) array_type -> ARRAY . LBRACKET type RANGE type RBRACKET OF type_name

    LBRACKET        shift and go to state 170


state 100

    (9) identifier_list -> IDENTIFIER COMMA identifier_list .

    COLON           reduce using rule 9 (identifier_list -> IDENTIFIER COMMA identifier_list .)


state 101

    (14) statements -> statement SEMICOLON statements .

    END             reduce using rule 14 (statements -> statement SEMICOLON statements .)
    UNTIL           reduce using rule 14 (statements -> statement SEMICOLON statements .)


state 102

    (140) writeln -> WRITELN LPAREN writeln_args . RPAREN

    RPAREN          shift and go to state 171


state 103

    (141) writeln_args -> type . COMMA writeln_args
    (142) writeln_args -> type .

    COMMA           shift and go to state 172
    RPAREN          reduce using rule 142 (writeln_args -> type .)


state 104

    (34) expression_paren -> LPAREN expressionGeneric RPAREN .

    ASSIGNMENT      reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    TIMES           reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    DIVISION        reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    RANGE           reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    PLUS            reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    MINUS           reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    DIV             reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    MOD             reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    RPAREN          reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    EQ              reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    NEQ             reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    LT              reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    GT              reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    LTE             reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    GTE             reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    AND             reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    OR              reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    NOT             reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    THEN            reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    DO              reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    COMMA           reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    SEMICOLON       reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    TO              reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    DOWNTO          reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    ELSE            reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)
    RBRACKET        reduce using rule 34 (expression_paren -> LPAREN expressionGeneric RPAREN .)


state 105

    (28) expressionGeneric -> expressionGeneric comparator . expression
    (29) expression -> . term
    (30) expression -> . expression operationAdd term
    (31) term -> . fator
    (32) term -> . term operationMul fator
    (33) fator -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    expression                     shift and go to state 173
    term                           shift and go to state 72
    fator                          shift and go to state 73
    type                           shift and go to state 74
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 106

    (69) comparator -> eq .

    INTEGER         reduce using rule 69 (comparator -> eq .)
    REAL            reduce using rule 69 (comparator -> eq .)
    STRING          reduce using rule 69 (comparator -> eq .)
    CHAR            reduce using rule 69 (comparator -> eq .)
    BOOLEAN         reduce using rule 69 (comparator -> eq .)
    IDENTIFIER      reduce using rule 69 (comparator -> eq .)
    LPAREN          reduce using rule 69 (comparator -> eq .)


state 107

    (70) comparator -> neq .

    INTEGER         reduce using rule 70 (comparator -> neq .)
    REAL            reduce using rule 70 (comparator -> neq .)
    STRING          reduce using rule 70 (comparator -> neq .)
    CHAR            reduce using rule 70 (comparator -> neq .)
    BOOLEAN         reduce using rule 70 (comparator -> neq .)
    IDENTIFIER      reduce using rule 70 (comparator -> neq .)
    LPAREN          reduce using rule 70 (comparator -> neq .)


state 108

    (71) comparator -> lt .

    INTEGER         reduce using rule 71 (comparator -> lt .)
    REAL            reduce using rule 71 (comparator -> lt .)
    STRING          reduce using rule 71 (comparator -> lt .)
    CHAR            reduce using rule 71 (comparator -> lt .)
    BOOLEAN         reduce using rule 71 (comparator -> lt .)
    IDENTIFIER      reduce using rule 71 (comparator -> lt .)
    LPAREN          reduce using rule 71 (comparator -> lt .)


state 109

    (72) comparator -> gt .

    INTEGER         reduce using rule 72 (comparator -> gt .)
    REAL            reduce using rule 72 (comparator -> gt .)
    STRING          reduce using rule 72 (comparator -> gt .)
    CHAR            reduce using rule 72 (comparator -> gt .)
    BOOLEAN         reduce using rule 72 (comparator -> gt .)
    IDENTIFIER      reduce using rule 72 (comparator -> gt .)
    LPAREN          reduce using rule 72 (comparator -> gt .)


state 110

    (73) comparator -> lte .

    INTEGER         reduce using rule 73 (comparator -> lte .)
    REAL            reduce using rule 73 (comparator -> lte .)
    STRING          reduce using rule 73 (comparator -> lte .)
    CHAR            reduce using rule 73 (comparator -> lte .)
    BOOLEAN         reduce using rule 73 (comparator -> lte .)
    IDENTIFIER      reduce using rule 73 (comparator -> lte .)
    LPAREN          reduce using rule 73 (comparator -> lte .)


state 111

    (74) comparator -> gte .

    INTEGER         reduce using rule 74 (comparator -> gte .)
    REAL            reduce using rule 74 (comparator -> gte .)
    STRING          reduce using rule 74 (comparator -> gte .)
    CHAR            reduce using rule 74 (comparator -> gte .)
    BOOLEAN         reduce using rule 74 (comparator -> gte .)
    IDENTIFIER      reduce using rule 74 (comparator -> gte .)
    LPAREN          reduce using rule 74 (comparator -> gte .)


state 112

    (75) comparator -> and .

    INTEGER         reduce using rule 75 (comparator -> and .)
    REAL            reduce using rule 75 (comparator -> and .)
    STRING          reduce using rule 75 (comparator -> and .)
    CHAR            reduce using rule 75 (comparator -> and .)
    BOOLEAN         reduce using rule 75 (comparator -> and .)
    IDENTIFIER      reduce using rule 75 (comparator -> and .)
    LPAREN          reduce using rule 75 (comparator -> and .)


state 113

    (76) comparator -> or .

    INTEGER         reduce using rule 76 (comparator -> or .)
    REAL            reduce using rule 76 (comparator -> or .)
    STRING          reduce using rule 76 (comparator -> or .)
    CHAR            reduce using rule 76 (comparator -> or .)
    BOOLEAN         reduce using rule 76 (comparator -> or .)
    IDENTIFIER      reduce using rule 76 (comparator -> or .)
    LPAREN          reduce using rule 76 (comparator -> or .)


state 114

    (77) comparator -> not .

    INTEGER         reduce using rule 77 (comparator -> not .)
    REAL            reduce using rule 77 (comparator -> not .)
    STRING          reduce using rule 77 (comparator -> not .)
    CHAR            reduce using rule 77 (comparator -> not .)
    BOOLEAN         reduce using rule 77 (comparator -> not .)
    IDENTIFIER      reduce using rule 77 (comparator -> not .)
    LPAREN          reduce using rule 77 (comparator -> not .)


state 115

    (78) eq -> EQ .

    INTEGER         reduce using rule 78 (eq -> EQ .)
    REAL            reduce using rule 78 (eq -> EQ .)
    STRING          reduce using rule 78 (eq -> EQ .)
    CHAR            reduce using rule 78 (eq -> EQ .)
    BOOLEAN         reduce using rule 78 (eq -> EQ .)
    IDENTIFIER      reduce using rule 78 (eq -> EQ .)
    LPAREN          reduce using rule 78 (eq -> EQ .)


state 116

    (79) neq -> NEQ .

    INTEGER         reduce using rule 79 (neq -> NEQ .)
    REAL            reduce using rule 79 (neq -> NEQ .)
    STRING          reduce using rule 79 (neq -> NEQ .)
    CHAR            reduce using rule 79 (neq -> NEQ .)
    BOOLEAN         reduce using rule 79 (neq -> NEQ .)
    IDENTIFIER      reduce using rule 79 (neq -> NEQ .)
    LPAREN          reduce using rule 79 (neq -> NEQ .)


state 117

    (80) lt -> LT .

    INTEGER         reduce using rule 80 (lt -> LT .)
    REAL            reduce using rule 80 (lt -> LT .)
    STRING          reduce using rule 80 (lt -> LT .)
    CHAR            reduce using rule 80 (lt -> LT .)
    BOOLEAN         reduce using rule 80 (lt -> LT .)
    IDENTIFIER      reduce using rule 80 (lt -> LT .)
    LPAREN          reduce using rule 80 (lt -> LT .)


state 118

    (81) gt -> GT .

    INTEGER         reduce using rule 81 (gt -> GT .)
    REAL            reduce using rule 81 (gt -> GT .)
    STRING          reduce using rule 81 (gt -> GT .)
    CHAR            reduce using rule 81 (gt -> GT .)
    BOOLEAN         reduce using rule 81 (gt -> GT .)
    IDENTIFIER      reduce using rule 81 (gt -> GT .)
    LPAREN          reduce using rule 81 (gt -> GT .)


state 119

    (82) lte -> LTE .

    INTEGER         reduce using rule 82 (lte -> LTE .)
    REAL            reduce using rule 82 (lte -> LTE .)
    STRING          reduce using rule 82 (lte -> LTE .)
    CHAR            reduce using rule 82 (lte -> LTE .)
    BOOLEAN         reduce using rule 82 (lte -> LTE .)
    IDENTIFIER      reduce using rule 82 (lte -> LTE .)
    LPAREN          reduce using rule 82 (lte -> LTE .)


state 120

    (83) gte -> GTE .

    INTEGER         reduce using rule 83 (gte -> GTE .)
    REAL            reduce using rule 83 (gte -> GTE .)
    STRING          reduce using rule 83 (gte -> GTE .)
    CHAR            reduce using rule 83 (gte -> GTE .)
    BOOLEAN         reduce using rule 83 (gte -> GTE .)
    IDENTIFIER      reduce using rule 83 (gte -> GTE .)
    LPAREN          reduce using rule 83 (gte -> GTE .)


state 121

    (84) and -> AND .

    INTEGER         reduce using rule 84 (and -> AND .)
    REAL            reduce using rule 84 (and -> AND .)
    STRING          reduce using rule 84 (and -> AND .)
    CHAR            reduce using rule 84 (and -> AND .)
    BOOLEAN         reduce using rule 84 (and -> AND .)
    IDENTIFIER      reduce using rule 84 (and -> AND .)
    LPAREN          reduce using rule 84 (and -> AND .)


state 122

    (85) or -> OR .

    INTEGER         reduce using rule 85 (or -> OR .)
    REAL            reduce using rule 85 (or -> OR .)
    STRING          reduce using rule 85 (or -> OR .)
    CHAR            reduce using rule 85 (or -> OR .)
    BOOLEAN         reduce using rule 85 (or -> OR .)
    IDENTIFIER      reduce using rule 85 (or -> OR .)
    LPAREN          reduce using rule 85 (or -> OR .)


state 123

    (86) not -> NOT .

    INTEGER         reduce using rule 86 (not -> NOT .)
    REAL            reduce using rule 86 (not -> NOT .)
    STRING          reduce using rule 86 (not -> NOT .)
    CHAR            reduce using rule 86 (not -> NOT .)
    BOOLEAN         reduce using rule 86 (not -> NOT .)
    IDENTIFIER      reduce using rule 86 (not -> NOT .)
    LPAREN          reduce using rule 86 (not -> NOT .)


state 124

    (30) expression -> expression operationAdd . term
    (31) term -> . fator
    (32) term -> . term operationMul fator
    (33) fator -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    term                           shift and go to state 174
    fator                          shift and go to state 73
    type                           shift and go to state 74
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 125

    (35) operationAdd -> plus .

    INTEGER         reduce using rule 35 (operationAdd -> plus .)
    REAL            reduce using rule 35 (operationAdd -> plus .)
    STRING          reduce using rule 35 (operationAdd -> plus .)
    CHAR            reduce using rule 35 (operationAdd -> plus .)
    BOOLEAN         reduce using rule 35 (operationAdd -> plus .)
    IDENTIFIER      reduce using rule 35 (operationAdd -> plus .)
    LPAREN          reduce using rule 35 (operationAdd -> plus .)


state 126

    (36) operationAdd -> minus .

    INTEGER         reduce using rule 36 (operationAdd -> minus .)
    REAL            reduce using rule 36 (operationAdd -> minus .)
    STRING          reduce using rule 36 (operationAdd -> minus .)
    CHAR            reduce using rule 36 (operationAdd -> minus .)
    BOOLEAN         reduce using rule 36 (operationAdd -> minus .)
    IDENTIFIER      reduce using rule 36 (operationAdd -> minus .)
    LPAREN          reduce using rule 36 (operationAdd -> minus .)


state 127

    (37) operationAdd -> div .

    INTEGER         reduce using rule 37 (operationAdd -> div .)
    REAL            reduce using rule 37 (operationAdd -> div .)
    STRING          reduce using rule 37 (operationAdd -> div .)
    CHAR            reduce using rule 37 (operationAdd -> div .)
    BOOLEAN         reduce using rule 37 (operationAdd -> div .)
    IDENTIFIER      reduce using rule 37 (operationAdd -> div .)
    LPAREN          reduce using rule 37 (operationAdd -> div .)


state 128

    (38) operationAdd -> mod .

    INTEGER         reduce using rule 38 (operationAdd -> mod .)
    REAL            reduce using rule 38 (operationAdd -> mod .)
    STRING          reduce using rule 38 (operationAdd -> mod .)
    CHAR            reduce using rule 38 (operationAdd -> mod .)
    BOOLEAN         reduce using rule 38 (operationAdd -> mod .)
    IDENTIFIER      reduce using rule 38 (operationAdd -> mod .)
    LPAREN          reduce using rule 38 (operationAdd -> mod .)


state 129

    (39) operationAdd -> RANGE .

    INTEGER         reduce using rule 39 (operationAdd -> RANGE .)
    REAL            reduce using rule 39 (operationAdd -> RANGE .)
    STRING          reduce using rule 39 (operationAdd -> RANGE .)
    CHAR            reduce using rule 39 (operationAdd -> RANGE .)
    BOOLEAN         reduce using rule 39 (operationAdd -> RANGE .)
    IDENTIFIER      reduce using rule 39 (operationAdd -> RANGE .)
    LPAREN          reduce using rule 39 (operationAdd -> RANGE .)


state 130

    (63) plus -> PLUS .

    INTEGER         reduce using rule 63 (plus -> PLUS .)
    REAL            reduce using rule 63 (plus -> PLUS .)
    STRING          reduce using rule 63 (plus -> PLUS .)
    CHAR            reduce using rule 63 (plus -> PLUS .)
    BOOLEAN         reduce using rule 63 (plus -> PLUS .)
    IDENTIFIER      reduce using rule 63 (plus -> PLUS .)
    LPAREN          reduce using rule 63 (plus -> PLUS .)


state 131

    (64) minus -> MINUS .

    INTEGER         reduce using rule 64 (minus -> MINUS .)
    REAL            reduce using rule 64 (minus -> MINUS .)
    STRING          reduce using rule 64 (minus -> MINUS .)
    CHAR            reduce using rule 64 (minus -> MINUS .)
    BOOLEAN         reduce using rule 64 (minus -> MINUS .)
    IDENTIFIER      reduce using rule 64 (minus -> MINUS .)
    LPAREN          reduce using rule 64 (minus -> MINUS .)


state 132

    (67) div -> DIV .

    INTEGER         reduce using rule 67 (div -> DIV .)
    REAL            reduce using rule 67 (div -> DIV .)
    STRING          reduce using rule 67 (div -> DIV .)
    CHAR            reduce using rule 67 (div -> DIV .)
    BOOLEAN         reduce using rule 67 (div -> DIV .)
    IDENTIFIER      reduce using rule 67 (div -> DIV .)
    LPAREN          reduce using rule 67 (div -> DIV .)


state 133

    (68) mod -> MOD .

    INTEGER         reduce using rule 68 (mod -> MOD .)
    REAL            reduce using rule 68 (mod -> MOD .)
    STRING          reduce using rule 68 (mod -> MOD .)
    CHAR            reduce using rule 68 (mod -> MOD .)
    BOOLEAN         reduce using rule 68 (mod -> MOD .)
    IDENTIFIER      reduce using rule 68 (mod -> MOD .)
    LPAREN          reduce using rule 68 (mod -> MOD .)


state 134

    (32) term -> term operationMul . fator
    (33) fator -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    fator                          shift and go to state 175
    type                           shift and go to state 74
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 135

    (40) operationMul -> times .

    INTEGER         reduce using rule 40 (operationMul -> times .)
    REAL            reduce using rule 40 (operationMul -> times .)
    STRING          reduce using rule 40 (operationMul -> times .)
    CHAR            reduce using rule 40 (operationMul -> times .)
    BOOLEAN         reduce using rule 40 (operationMul -> times .)
    IDENTIFIER      reduce using rule 40 (operationMul -> times .)
    LPAREN          reduce using rule 40 (operationMul -> times .)


state 136

    (41) operationMul -> division .

    INTEGER         reduce using rule 41 (operationMul -> division .)
    REAL            reduce using rule 41 (operationMul -> division .)
    STRING          reduce using rule 41 (operationMul -> division .)
    CHAR            reduce using rule 41 (operationMul -> division .)
    BOOLEAN         reduce using rule 41 (operationMul -> division .)
    IDENTIFIER      reduce using rule 41 (operationMul -> division .)
    LPAREN          reduce using rule 41 (operationMul -> division .)


state 137

    (65) times -> TIMES .

    INTEGER         reduce using rule 65 (times -> TIMES .)
    REAL            reduce using rule 65 (times -> TIMES .)
    STRING          reduce using rule 65 (times -> TIMES .)
    CHAR            reduce using rule 65 (times -> TIMES .)
    BOOLEAN         reduce using rule 65 (times -> TIMES .)
    IDENTIFIER      reduce using rule 65 (times -> TIMES .)
    LPAREN          reduce using rule 65 (times -> TIMES .)


state 138

    (66) division -> DIVISION .

    INTEGER         reduce using rule 66 (division -> DIVISION .)
    REAL            reduce using rule 66 (division -> DIVISION .)
    STRING          reduce using rule 66 (division -> DIVISION .)
    CHAR            reduce using rule 66 (division -> DIVISION .)
    BOOLEAN         reduce using rule 66 (division -> DIVISION .)
    IDENTIFIER      reduce using rule 66 (division -> DIVISION .)
    LPAREN          reduce using rule 66 (division -> DIVISION .)


state 139

    (117) func_call -> prepare_func_call LPAREN . arg_list RPAREN
    (119) arg_list -> . expressionGeneric COMMA arg_list
    (120) arg_list -> . expressionGeneric
    (121) arg_list -> .
    (27) expressionGeneric -> . expression
    (28) expressionGeneric -> . expressionGeneric comparator expression
    (29) expression -> . term
    (30) expression -> . expression operationAdd term
    (31) term -> . fator
    (32) term -> . term operationMul fator
    (33) fator -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    RPAREN          reduce using rule 121 (arg_list -> .)
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    prepare_func_call              shift and go to state 76
    arg_list                       shift and go to state 146
    expressionGeneric              shift and go to state 176
    expression                     shift and go to state 71
    term                           shift and go to state 72
    fator                          shift and go to state 73
    type                           shift and go to state 74
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53

state 140

    (24) assignment -> type ASSIGNMENT expressionGeneric .
    (28) expressionGeneric -> expressionGeneric . comparator expression
    (69) comparator -> . eq
    (70) comparator -> . neq
    (71) comparator -> . lt
    (72) comparator -> . gt
    (73) comparator -> . lte
    (74) comparator -> . gte
    (75) comparator -> . and
    (76) comparator -> . or
    (77) comparator -> . not
    (78) eq -> . EQ
    (79) neq -> . NEQ
    (80) lt -> . LT
    (81) gt -> . GT
    (82) lte -> . LTE
    (83) gte -> . GTE
    (84) and -> . AND
    (85) or -> . OR
    (86) not -> . NOT

    SEMICOLON       reduce using rule 24 (assignment -> type ASSIGNMENT expressionGeneric .)
    TO              reduce using rule 24 (assignment -> type ASSIGNMENT expressionGeneric .)
    DOWNTO          reduce using rule 24 (assignment -> type ASSIGNMENT expressionGeneric .)
    ELSE            reduce using rule 24 (assignment -> type ASSIGNMENT expressionGeneric .)
    EQ              shift and go to state 115
    NEQ             shift and go to state 116
    LT              shift and go to state 117
    GT              shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    AND             shift and go to state 121
    OR              shift and go to state 122
    NOT             shift and go to state 123

    comparator                     shift and go to state 105
    eq                             shift and go to state 106
    neq                            shift and go to state 107
    lt                             shift and go to state 108
    gt                             shift and go to state 109
    lte                            shift and go to state 110
    gte                            shift and go to state 111
    and                            shift and go to state 112
    or                             shift and go to state 113
    not                            shift and go to state 114

state 141

    (25) assignment -> type ASSIGNMENT length .

    SEMICOLON       reduce using rule 25 (assignment -> type ASSIGNMENT length .)
    TO              reduce using rule 25 (assignment -> type ASSIGNMENT length .)
    DOWNTO          reduce using rule 25 (assignment -> type ASSIGNMENT length .)
    ELSE            reduce using rule 25 (assignment -> type ASSIGNMENT length .)


state 142

    (26) assignment -> type ASSIGNMENT negation .

    SEMICOLON       reduce using rule 26 (assignment -> type ASSIGNMENT negation .)
    TO              reduce using rule 26 (assignment -> type ASSIGNMENT negation .)
    DOWNTO          reduce using rule 26 (assignment -> type ASSIGNMENT negation .)
    ELSE            reduce using rule 26 (assignment -> type ASSIGNMENT negation .)


state 143

    (104) length -> LENGTH . LPAREN type RPAREN

    LPAREN          shift and go to state 177


state 144

    (87) negation -> not . boolean
    (88) negation -> not . func_call
    (61) boolean -> . BOOLEAN
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 180

    boolean                        shift and go to state 178
    func_call                      shift and go to state 179
    prepare_func_call              shift and go to state 76

state 145

    (101) procedure_call -> prepare_func_call LPAREN procedure_arg_list . RPAREN

    RPAREN          shift and go to state 181


state 146

    (117) func_call -> prepare_func_call LPAREN arg_list . RPAREN

    RPAREN          shift and go to state 182


state 147

    (102) procedure_arg_list -> expressionGeneric . COMMA procedure_arg_list
    (103) procedure_arg_list -> expressionGeneric .
    (119) arg_list -> expressionGeneric . COMMA arg_list
    (120) arg_list -> expressionGeneric .
    (28) expressionGeneric -> expressionGeneric . comparator expression
    (69) comparator -> . eq
    (70) comparator -> . neq
    (71) comparator -> . lt
    (72) comparator -> . gt
    (73) comparator -> . lte
    (74) comparator -> . gte
    (75) comparator -> . and
    (76) comparator -> . or
    (77) comparator -> . not
    (78) eq -> . EQ
    (79) neq -> . NEQ
    (80) lt -> . LT
    (81) gt -> . GT
    (82) lte -> . LTE
    (83) gte -> . GTE
    (84) and -> . AND
    (85) or -> . OR
    (86) not -> . NOT

  ! reduce/reduce conflict for RPAREN resolved using rule 103 (procedure_arg_list -> expressionGeneric .)
    COMMA           shift and go to state 183
    RPAREN          reduce using rule 103 (procedure_arg_list -> expressionGeneric .)
    EQ              shift and go to state 115
    NEQ             shift and go to state 116
    LT              shift and go to state 117
    GT              shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    AND             shift and go to state 121
    OR              shift and go to state 122
    NOT             shift and go to state 123

  ! RPAREN          [ reduce using rule 120 (arg_list -> expressionGeneric .) ]

    comparator                     shift and go to state 105
    eq                             shift and go to state 106
    neq                            shift and go to state 107
    lt                             shift and go to state 108
    gt                             shift and go to state 109
    lte                            shift and go to state 110
    gte                            shift and go to state 111
    and                            shift and go to state 112
    or                             shift and go to state 113
    not                            shift and go to state 114

state 148

    (122) cond_if -> IF condition THEN . statement
    (123) cond_if -> IF condition THEN . statement ELSE statement
    (124) cond_if -> IF condition THEN . statement ELSE if_body
    (125) cond_if -> IF condition THEN . if_body
    (126) cond_if -> IF condition THEN . if_body ELSE if_body
    (127) cond_if -> IF condition THEN . if_body ELSE statement
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (129) if_body -> . BEGIN statements END
    (140) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT expressionGeneric
    (25) assignment -> . type ASSIGNMENT length
    (26) assignment -> . type ASSIGNMENT negation
    (100) procedure_call -> . prepare_func_call
    (101) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (122) cond_if -> . IF condition THEN statement
    (123) cond_if -> . IF condition THEN statement ELSE statement
    (124) cond_if -> . IF condition THEN statement ELSE if_body
    (125) cond_if -> . IF condition THEN if_body
    (126) cond_if -> . IF condition THEN if_body ELSE if_body
    (127) cond_if -> . IF condition THEN if_body ELSE statement
    (136) while_loop -> . WHILE condition DO statement
    (137) while_loop -> . WHILE condition DO if_body
    (132) for_loop -> . FOR assignment to type DO statement
    (133) for_loop -> . FOR assignment to type DO if_body
    (134) for_loop -> . FOR assignment downto type DO statement
    (135) for_loop -> . FOR assignment downto type DO if_body
    (138) repeat_loop -> . REPEAT statements UNTIL condition
    (139) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (118) prepare_func_call -> . IDENTIFIER
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN

    BEGIN           shift and go to state 186
    WRITELN         shift and go to state 36
    IF              shift and go to state 40
    WHILE           shift and go to state 41
    FOR             shift and go to state 42
    REPEAT          shift and go to state 43
    READLN          shift and go to state 44
    IDENTIFIER      shift and go to state 54
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    LPAREN          shift and go to state 37

    statement                      shift and go to state 184
    if_body                        shift and go to state 185
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 38
    prepare_func_call              shift and go to state 39
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53

state 149

    (136) while_loop -> WHILE condition DO . statement
    (137) while_loop -> WHILE condition DO . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (129) if_body -> . BEGIN statements END
    (140) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT expressionGeneric
    (25) assignment -> . type ASSIGNMENT length
    (26) assignment -> . type ASSIGNMENT negation
    (100) procedure_call -> . prepare_func_call
    (101) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (122) cond_if -> . IF condition THEN statement
    (123) cond_if -> . IF condition THEN statement ELSE statement
    (124) cond_if -> . IF condition THEN statement ELSE if_body
    (125) cond_if -> . IF condition THEN if_body
    (126) cond_if -> . IF condition THEN if_body ELSE if_body
    (127) cond_if -> . IF condition THEN if_body ELSE statement
    (136) while_loop -> . WHILE condition DO statement
    (137) while_loop -> . WHILE condition DO if_body
    (132) for_loop -> . FOR assignment to type DO statement
    (133) for_loop -> . FOR assignment to type DO if_body
    (134) for_loop -> . FOR assignment downto type DO statement
    (135) for_loop -> . FOR assignment downto type DO if_body
    (138) repeat_loop -> . REPEAT statements UNTIL condition
    (139) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (118) prepare_func_call -> . IDENTIFIER
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN

    BEGIN           shift and go to state 186
    WRITELN         shift and go to state 36
    IF              shift and go to state 40
    WHILE           shift and go to state 41
    FOR             shift and go to state 42
    REPEAT          shift and go to state 43
    READLN          shift and go to state 44
    IDENTIFIER      shift and go to state 54
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    LPAREN          shift and go to state 37

    statement                      shift and go to state 187
    if_body                        shift and go to state 188
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 38
    prepare_func_call              shift and go to state 39
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53

state 150

    (132) for_loop -> FOR assignment to . type DO statement
    (133) for_loop -> FOR assignment to . type DO if_body
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    type                           shift and go to state 189
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 151

    (134) for_loop -> FOR assignment downto . type DO statement
    (135) for_loop -> FOR assignment downto . type DO if_body
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    type                           shift and go to state 190
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 152

    (130) to -> TO .

    INTEGER         reduce using rule 130 (to -> TO .)
    REAL            reduce using rule 130 (to -> TO .)
    STRING          reduce using rule 130 (to -> TO .)
    CHAR            reduce using rule 130 (to -> TO .)
    BOOLEAN         reduce using rule 130 (to -> TO .)
    IDENTIFIER      reduce using rule 130 (to -> TO .)
    LPAREN          reduce using rule 130 (to -> TO .)


state 153

    (131) downto -> DOWNTO .

    INTEGER         reduce using rule 131 (downto -> DOWNTO .)
    REAL            reduce using rule 131 (downto -> DOWNTO .)
    STRING          reduce using rule 131 (downto -> DOWNTO .)
    CHAR            reduce using rule 131 (downto -> DOWNTO .)
    BOOLEAN         reduce using rule 131 (downto -> DOWNTO .)
    IDENTIFIER      reduce using rule 131 (downto -> DOWNTO .)
    LPAREN          reduce using rule 131 (downto -> DOWNTO .)


state 154

    (138) repeat_loop -> REPEAT statements UNTIL . condition
    (128) condition -> . expressionGeneric
    (27) expressionGeneric -> . expression
    (28) expressionGeneric -> . expressionGeneric comparator expression
    (29) expression -> . term
    (30) expression -> . expression operationAdd term
    (31) term -> . fator
    (32) term -> . term operationMul fator
    (33) fator -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    condition                      shift and go to state 191
    expressionGeneric              shift and go to state 80
    expression                     shift and go to state 71
    term                           shift and go to state 72
    fator                          shift and go to state 73
    type                           shift and go to state 74
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 155

    (139) readln -> READLN LPAREN type . RPAREN

    RPAREN          shift and go to state 192


state 156

    (12) array_access -> IDENTIFIER LBRACKET expressionGeneric . RBRACKET
    (28) expressionGeneric -> expressionGeneric . comparator expression
    (69) comparator -> . eq
    (70) comparator -> . neq
    (71) comparator -> . lt
    (72) comparator -> . gt
    (73) comparator -> . lte
    (74) comparator -> . gte
    (75) comparator -> . and
    (76) comparator -> . or
    (77) comparator -> . not
    (78) eq -> . EQ
    (79) neq -> . NEQ
    (80) lt -> . LT
    (81) gt -> . GT
    (82) lte -> . LTE
    (83) gte -> . GTE
    (84) and -> . AND
    (85) or -> . OR
    (86) not -> . NOT

    RBRACKET        shift and go to state 193
    EQ              shift and go to state 115
    NEQ             shift and go to state 116
    LT              shift and go to state 117
    GT              shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    AND             shift and go to state 121
    OR              shift and go to state 122
    NOT             shift and go to state 123

    comparator                     shift and go to state 105
    eq                             shift and go to state 106
    neq                            shift and go to state 107
    lt                             shift and go to state 108
    gt                             shift and go to state 109
    lte                            shift and go to state 110
    gte                            shift and go to state 111
    and                            shift and go to state 112
    or                             shift and go to state 113
    not                            shift and go to state 114

state 157

    (107) function_with_vars -> func_header SEMICOLON VAR func_variable_declaration . func_body SEMICOLON
    (116) func_body -> . BEGIN statements END

    BEGIN           shift and go to state 88

    func_body                      shift and go to state 194

state 158

    (114) func_variable_declaration -> identifier_list . COLON type_name SEMICOLON func_variable_declaration
    (115) func_variable_declaration -> identifier_list . COLON type_name SEMICOLON

    COLON           shift and go to state 195


state 159

    (108) function_with_no_vars -> func_header SEMICOLON func_body SEMICOLON .

    VAR             reduce using rule 108 (function_with_no_vars -> func_header SEMICOLON func_body SEMICOLON .)
    BEGIN           reduce using rule 108 (function_with_no_vars -> func_header SEMICOLON func_body SEMICOLON .)
    PROCEDURE       reduce using rule 108 (function_with_no_vars -> func_header SEMICOLON func_body SEMICOLON .)
    FUNCTION        reduce using rule 108 (function_with_no_vars -> func_header SEMICOLON func_body SEMICOLON .)


state 160

    (116) func_body -> BEGIN statements . END

    END             shift and go to state 196


state 161

    (93) procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 197


state 162

    (95) procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR . func_variable_declaration procedure_body SEMICOLON
    (114) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON func_variable_declaration
    (115) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 23

    func_variable_declaration      shift and go to state 198
    identifier_list                shift and go to state 158

state 163

    (99) procedure_body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (140) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT expressionGeneric
    (25) assignment -> . type ASSIGNMENT length
    (26) assignment -> . type ASSIGNMENT negation
    (100) procedure_call -> . prepare_func_call
    (101) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (122) cond_if -> . IF condition THEN statement
    (123) cond_if -> . IF condition THEN statement ELSE statement
    (124) cond_if -> . IF condition THEN statement ELSE if_body
    (125) cond_if -> . IF condition THEN if_body
    (126) cond_if -> . IF condition THEN if_body ELSE if_body
    (127) cond_if -> . IF condition THEN if_body ELSE statement
    (136) while_loop -> . WHILE condition DO statement
    (137) while_loop -> . WHILE condition DO if_body
    (132) for_loop -> . FOR assignment to type DO statement
    (133) for_loop -> . FOR assignment to type DO if_body
    (134) for_loop -> . FOR assignment downto type DO statement
    (135) for_loop -> . FOR assignment downto type DO if_body
    (138) repeat_loop -> . REPEAT statements UNTIL condition
    (139) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (118) prepare_func_call -> . IDENTIFIER
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN

    WRITELN         shift and go to state 36
    IF              shift and go to state 40
    WHILE           shift and go to state 41
    FOR             shift and go to state 42
    REPEAT          shift and go to state 43
    READLN          shift and go to state 44
    IDENTIFIER      shift and go to state 54
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    LPAREN          shift and go to state 37

    statements                     shift and go to state 199
    statement                      shift and go to state 27
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 38
    prepare_func_call              shift and go to state 39
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53

state 164

    (94) procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args . RPAREN SEMICOLON procedure_body SEMICOLON
    (96) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args . RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON

    RPAREN          shift and go to state 200


state 165

    (111) func_args -> func_arglist . SEMICOLON func_args
    (112) func_args -> func_arglist .

    SEMICOLON       shift and go to state 201
    RPAREN          reduce using rule 112 (func_args -> func_arglist .)


state 166

    (113) func_arglist -> identifier_list . COLON type_name

    COLON           shift and go to state 202


state 167

    (109) func_header -> FUNCTION IDENTIFIER LPAREN func_args . RPAREN COLON type_name

    RPAREN          shift and go to state 203


state 168

    (110) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN . COLON type_name

    COLON           shift and go to state 204


state 169

    (7) variable_declaration -> identifier_list COLON type_name SEMICOLON . variable_declaration
    (8) variable_declaration -> identifier_list COLON type_name SEMICOLON .
    (7) variable_declaration -> . identifier_list COLON type_name SEMICOLON variable_declaration
    (8) variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    BEGIN           reduce using rule 8 (variable_declaration -> identifier_list COLON type_name SEMICOLON .)
    IDENTIFIER      shift and go to state 23

    identifier_list                shift and go to state 22
    variable_declaration           shift and go to state 205

state 170

    (11) array_type -> ARRAY LBRACKET . type RANGE type RBRACKET OF type_name
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    type                           shift and go to state 206
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 171

    (140) writeln -> WRITELN LPAREN writeln_args RPAREN .

    SEMICOLON       reduce using rule 140 (writeln -> WRITELN LPAREN writeln_args RPAREN .)
    ELSE            reduce using rule 140 (writeln -> WRITELN LPAREN writeln_args RPAREN .)


state 172

    (141) writeln_args -> type COMMA . writeln_args
    (141) writeln_args -> . type COMMA writeln_args
    (142) writeln_args -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    type                           shift and go to state 103
    writeln_args                   shift and go to state 207
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 173

    (28) expressionGeneric -> expressionGeneric comparator expression .
    (30) expression -> expression . operationAdd term
    (35) operationAdd -> . plus
    (36) operationAdd -> . minus
    (37) operationAdd -> . div
    (38) operationAdd -> . mod
    (39) operationAdd -> . RANGE
    (63) plus -> . PLUS
    (64) minus -> . MINUS
    (67) div -> . DIV
    (68) mod -> . MOD

    RPAREN          reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    EQ              reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    NEQ             reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    LT              reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    GT              reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    LTE             reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    GTE             reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    AND             reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    OR              reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    NOT             reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    THEN            reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    DO              reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    SEMICOLON       reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    TO              reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    DOWNTO          reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    ELSE            reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    COMMA           reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    RBRACKET        reduce using rule 28 (expressionGeneric -> expressionGeneric comparator expression .)
    RANGE           shift and go to state 129
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    DIV             shift and go to state 132
    MOD             shift and go to state 133

    operationAdd                   shift and go to state 124
    plus                           shift and go to state 125
    minus                          shift and go to state 126
    div                            shift and go to state 127
    mod                            shift and go to state 128

state 174

    (30) expression -> expression operationAdd term .
    (32) term -> term . operationMul fator
    (40) operationMul -> . times
    (41) operationMul -> . division
    (65) times -> . TIMES
    (66) division -> . DIVISION

    RANGE           reduce using rule 30 (expression -> expression operationAdd term .)
    PLUS            reduce using rule 30 (expression -> expression operationAdd term .)
    MINUS           reduce using rule 30 (expression -> expression operationAdd term .)
    DIV             reduce using rule 30 (expression -> expression operationAdd term .)
    MOD             reduce using rule 30 (expression -> expression operationAdd term .)
    RPAREN          reduce using rule 30 (expression -> expression operationAdd term .)
    EQ              reduce using rule 30 (expression -> expression operationAdd term .)
    NEQ             reduce using rule 30 (expression -> expression operationAdd term .)
    LT              reduce using rule 30 (expression -> expression operationAdd term .)
    GT              reduce using rule 30 (expression -> expression operationAdd term .)
    LTE             reduce using rule 30 (expression -> expression operationAdd term .)
    GTE             reduce using rule 30 (expression -> expression operationAdd term .)
    AND             reduce using rule 30 (expression -> expression operationAdd term .)
    OR              reduce using rule 30 (expression -> expression operationAdd term .)
    NOT             reduce using rule 30 (expression -> expression operationAdd term .)
    THEN            reduce using rule 30 (expression -> expression operationAdd term .)
    DO              reduce using rule 30 (expression -> expression operationAdd term .)
    SEMICOLON       reduce using rule 30 (expression -> expression operationAdd term .)
    TO              reduce using rule 30 (expression -> expression operationAdd term .)
    DOWNTO          reduce using rule 30 (expression -> expression operationAdd term .)
    ELSE            reduce using rule 30 (expression -> expression operationAdd term .)
    COMMA           reduce using rule 30 (expression -> expression operationAdd term .)
    RBRACKET        reduce using rule 30 (expression -> expression operationAdd term .)
    TIMES           shift and go to state 137
    DIVISION        shift and go to state 138

    operationMul                   shift and go to state 134
    times                          shift and go to state 135
    division                       shift and go to state 136

state 175

    (32) term -> term operationMul fator .

    TIMES           reduce using rule 32 (term -> term operationMul fator .)
    DIVISION        reduce using rule 32 (term -> term operationMul fator .)
    RANGE           reduce using rule 32 (term -> term operationMul fator .)
    PLUS            reduce using rule 32 (term -> term operationMul fator .)
    MINUS           reduce using rule 32 (term -> term operationMul fator .)
    DIV             reduce using rule 32 (term -> term operationMul fator .)
    MOD             reduce using rule 32 (term -> term operationMul fator .)
    RPAREN          reduce using rule 32 (term -> term operationMul fator .)
    EQ              reduce using rule 32 (term -> term operationMul fator .)
    NEQ             reduce using rule 32 (term -> term operationMul fator .)
    LT              reduce using rule 32 (term -> term operationMul fator .)
    GT              reduce using rule 32 (term -> term operationMul fator .)
    LTE             reduce using rule 32 (term -> term operationMul fator .)
    GTE             reduce using rule 32 (term -> term operationMul fator .)
    AND             reduce using rule 32 (term -> term operationMul fator .)
    OR              reduce using rule 32 (term -> term operationMul fator .)
    NOT             reduce using rule 32 (term -> term operationMul fator .)
    THEN            reduce using rule 32 (term -> term operationMul fator .)
    DO              reduce using rule 32 (term -> term operationMul fator .)
    SEMICOLON       reduce using rule 32 (term -> term operationMul fator .)
    TO              reduce using rule 32 (term -> term operationMul fator .)
    DOWNTO          reduce using rule 32 (term -> term operationMul fator .)
    ELSE            reduce using rule 32 (term -> term operationMul fator .)
    COMMA           reduce using rule 32 (term -> term operationMul fator .)
    RBRACKET        reduce using rule 32 (term -> term operationMul fator .)


state 176

    (119) arg_list -> expressionGeneric . COMMA arg_list
    (120) arg_list -> expressionGeneric .
    (28) expressionGeneric -> expressionGeneric . comparator expression
    (69) comparator -> . eq
    (70) comparator -> . neq
    (71) comparator -> . lt
    (72) comparator -> . gt
    (73) comparator -> . lte
    (74) comparator -> . gte
    (75) comparator -> . and
    (76) comparator -> . or
    (77) comparator -> . not
    (78) eq -> . EQ
    (79) neq -> . NEQ
    (80) lt -> . LT
    (81) gt -> . GT
    (82) lte -> . LTE
    (83) gte -> . GTE
    (84) and -> . AND
    (85) or -> . OR
    (86) not -> . NOT

    COMMA           shift and go to state 208
    RPAREN          reduce using rule 120 (arg_list -> expressionGeneric .)
    EQ              shift and go to state 115
    NEQ             shift and go to state 116
    LT              shift and go to state 117
    GT              shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    AND             shift and go to state 121
    OR              shift and go to state 122
    NOT             shift and go to state 123

    comparator                     shift and go to state 105
    eq                             shift and go to state 106
    neq                            shift and go to state 107
    lt                             shift and go to state 108
    gt                             shift and go to state 109
    lte                            shift and go to state 110
    gte                            shift and go to state 111
    and                            shift and go to state 112
    or                             shift and go to state 113
    not                            shift and go to state 114

state 177

    (104) length -> LENGTH LPAREN . type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    type                           shift and go to state 209
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 178

    (87) negation -> not boolean .

    SEMICOLON       reduce using rule 87 (negation -> not boolean .)
    TO              reduce using rule 87 (negation -> not boolean .)
    DOWNTO          reduce using rule 87 (negation -> not boolean .)
    ELSE            reduce using rule 87 (negation -> not boolean .)


state 179

    (88) negation -> not func_call .

    SEMICOLON       reduce using rule 88 (negation -> not func_call .)
    TO              reduce using rule 88 (negation -> not func_call .)
    DOWNTO          reduce using rule 88 (negation -> not func_call .)
    ELSE            reduce using rule 88 (negation -> not func_call .)


state 180

    (118) prepare_func_call -> IDENTIFIER .

    LPAREN          reduce using rule 118 (prepare_func_call -> IDENTIFIER .)


state 181

    (101) procedure_call -> prepare_func_call LPAREN procedure_arg_list RPAREN .

    SEMICOLON       reduce using rule 101 (procedure_call -> prepare_func_call LPAREN procedure_arg_list RPAREN .)
    ELSE            reduce using rule 101 (procedure_call -> prepare_func_call LPAREN procedure_arg_list RPAREN .)


state 182

    (117) func_call -> prepare_func_call LPAREN arg_list RPAREN .

    ASSIGNMENT      reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    TIMES           reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    DIVISION        reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    RANGE           reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    PLUS            reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    MINUS           reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    DIV             reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    MOD             reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    RPAREN          reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    EQ              reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    NEQ             reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    LT              reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    GT              reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    LTE             reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    GTE             reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    AND             reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    OR              reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    NOT             reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    THEN            reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    DO              reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    COMMA           reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    SEMICOLON       reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    TO              reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    DOWNTO          reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    ELSE            reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)
    RBRACKET        reduce using rule 117 (func_call -> prepare_func_call LPAREN arg_list RPAREN .)


state 183

    (102) procedure_arg_list -> expressionGeneric COMMA . procedure_arg_list
    (119) arg_list -> expressionGeneric COMMA . arg_list
    (102) procedure_arg_list -> . expressionGeneric COMMA procedure_arg_list
    (103) procedure_arg_list -> . expressionGeneric
    (119) arg_list -> . expressionGeneric COMMA arg_list
    (120) arg_list -> . expressionGeneric
    (121) arg_list -> .
    (27) expressionGeneric -> . expression
    (28) expressionGeneric -> . expressionGeneric comparator expression
    (29) expression -> . term
    (30) expression -> . expression operationAdd term
    (31) term -> . fator
    (32) term -> . term operationMul fator
    (33) fator -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    RPAREN          reduce using rule 121 (arg_list -> .)
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    expressionGeneric              shift and go to state 147
    procedure_arg_list             shift and go to state 210
    arg_list                       shift and go to state 211
    expression                     shift and go to state 71
    term                           shift and go to state 72
    fator                          shift and go to state 73
    type                           shift and go to state 74
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 184

    (122) cond_if -> IF condition THEN statement .
    (123) cond_if -> IF condition THEN statement . ELSE statement
    (124) cond_if -> IF condition THEN statement . ELSE if_body

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 122 (cond_if -> IF condition THEN statement .)
    ELSE            shift and go to state 212

  ! ELSE            [ reduce using rule 122 (cond_if -> IF condition THEN statement .) ]


state 185

    (125) cond_if -> IF condition THEN if_body .
    (126) cond_if -> IF condition THEN if_body . ELSE if_body
    (127) cond_if -> IF condition THEN if_body . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 125 (cond_if -> IF condition THEN if_body .)
    ELSE            shift and go to state 213

  ! ELSE            [ reduce using rule 125 (cond_if -> IF condition THEN if_body .) ]


state 186

    (129) if_body -> BEGIN . statements END
    (14) statements -> . statement SEMICOLON statements
    (15) statements -> . statement SEMICOLON
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (140) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT expressionGeneric
    (25) assignment -> . type ASSIGNMENT length
    (26) assignment -> . type ASSIGNMENT negation
    (100) procedure_call -> . prepare_func_call
    (101) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (122) cond_if -> . IF condition THEN statement
    (123) cond_if -> . IF condition THEN statement ELSE statement
    (124) cond_if -> . IF condition THEN statement ELSE if_body
    (125) cond_if -> . IF condition THEN if_body
    (126) cond_if -> . IF condition THEN if_body ELSE if_body
    (127) cond_if -> . IF condition THEN if_body ELSE statement
    (136) while_loop -> . WHILE condition DO statement
    (137) while_loop -> . WHILE condition DO if_body
    (132) for_loop -> . FOR assignment to type DO statement
    (133) for_loop -> . FOR assignment to type DO if_body
    (134) for_loop -> . FOR assignment downto type DO statement
    (135) for_loop -> . FOR assignment downto type DO if_body
    (138) repeat_loop -> . REPEAT statements UNTIL condition
    (139) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (118) prepare_func_call -> . IDENTIFIER
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN

    WRITELN         shift and go to state 36
    IF              shift and go to state 40
    WHILE           shift and go to state 41
    FOR             shift and go to state 42
    REPEAT          shift and go to state 43
    READLN          shift and go to state 44
    IDENTIFIER      shift and go to state 54
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    LPAREN          shift and go to state 37

    statements                     shift and go to state 214
    statement                      shift and go to state 27
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 38
    prepare_func_call              shift and go to state 39
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53

state 187

    (136) while_loop -> WHILE condition DO statement .

    SEMICOLON       reduce using rule 136 (while_loop -> WHILE condition DO statement .)
    ELSE            reduce using rule 136 (while_loop -> WHILE condition DO statement .)


state 188

    (137) while_loop -> WHILE condition DO if_body .

    SEMICOLON       reduce using rule 137 (while_loop -> WHILE condition DO if_body .)
    ELSE            reduce using rule 137 (while_loop -> WHILE condition DO if_body .)


state 189

    (132) for_loop -> FOR assignment to type . DO statement
    (133) for_loop -> FOR assignment to type . DO if_body

    DO              shift and go to state 215


state 190

    (134) for_loop -> FOR assignment downto type . DO statement
    (135) for_loop -> FOR assignment downto type . DO if_body

    DO              shift and go to state 216


state 191

    (138) repeat_loop -> REPEAT statements UNTIL condition .

    SEMICOLON       reduce using rule 138 (repeat_loop -> REPEAT statements UNTIL condition .)
    ELSE            reduce using rule 138 (repeat_loop -> REPEAT statements UNTIL condition .)


state 192

    (139) readln -> READLN LPAREN type RPAREN .

    SEMICOLON       reduce using rule 139 (readln -> READLN LPAREN type RPAREN .)
    ELSE            reduce using rule 139 (readln -> READLN LPAREN type RPAREN .)


state 193

    (12) array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .

    ASSIGNMENT      reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    TIMES           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    DIVISION        reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    RANGE           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    PLUS            reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    MINUS           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    DIV             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    MOD             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    RPAREN          reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    EQ              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    NEQ             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    LT              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    GT              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    LTE             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    GTE             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    AND             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    OR              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    NOT             reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    THEN            reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    DO              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    COMMA           reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    SEMICOLON       reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    TO              reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    DOWNTO          reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    ELSE            reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)
    RBRACKET        reduce using rule 12 (array_access -> IDENTIFIER LBRACKET expressionGeneric RBRACKET .)


state 194

    (107) function_with_vars -> func_header SEMICOLON VAR func_variable_declaration func_body . SEMICOLON

    SEMICOLON       shift and go to state 217


state 195

    (114) func_variable_declaration -> identifier_list COLON . type_name SEMICOLON func_variable_declaration
    (115) func_variable_declaration -> identifier_list COLON . type_name SEMICOLON
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 93
    NREAL           shift and go to state 94
    NSTRING         shift and go to state 95
    NCHAR           shift and go to state 96
    NBOOLEAN        shift and go to state 97
    ARRAY           shift and go to state 99

    type_name                      shift and go to state 218
    array_type                     shift and go to state 98

state 196

    (116) func_body -> BEGIN statements END .

    SEMICOLON       reduce using rule 116 (func_body -> BEGIN statements END .)


state 197

    (93) procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .

    VAR             reduce using rule 93 (procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    BEGIN           reduce using rule 93 (procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 93 (procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 93 (procedure_no_args_no_vars -> PROCEDURE IDENTIFIER SEMICOLON procedure_body SEMICOLON .)


state 198

    (95) procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration . procedure_body SEMICOLON
    (99) procedure_body -> . BEGIN statements END

    BEGIN           shift and go to state 163

    procedure_body                 shift and go to state 219

state 199

    (99) procedure_body -> BEGIN statements . END

    END             shift and go to state 220


state 200

    (94) procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN . SEMICOLON procedure_body SEMICOLON
    (96) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN . SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON

    SEMICOLON       shift and go to state 221


state 201

    (111) func_args -> func_arglist SEMICOLON . func_args
    (111) func_args -> . func_arglist SEMICOLON func_args
    (112) func_args -> . func_arglist
    (113) func_arglist -> . identifier_list COLON type_name
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 23

    func_arglist                   shift and go to state 165
    func_args                      shift and go to state 222
    identifier_list                shift and go to state 166

state 202

    (113) func_arglist -> identifier_list COLON . type_name
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 93
    NREAL           shift and go to state 94
    NSTRING         shift and go to state 95
    NCHAR           shift and go to state 96
    NBOOLEAN        shift and go to state 97
    ARRAY           shift and go to state 99

    type_name                      shift and go to state 223
    array_type                     shift and go to state 98

state 203

    (109) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN . COLON type_name

    COLON           shift and go to state 224


state 204

    (110) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON . type_name
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 93
    NREAL           shift and go to state 94
    NSTRING         shift and go to state 95
    NCHAR           shift and go to state 96
    NBOOLEAN        shift and go to state 97
    ARRAY           shift and go to state 99

    type_name                      shift and go to state 225
    array_type                     shift and go to state 98

state 205

    (7) variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .

    BEGIN           reduce using rule 7 (variable_declaration -> identifier_list COLON type_name SEMICOLON variable_declaration .)


state 206

    (11) array_type -> ARRAY LBRACKET type . RANGE type RBRACKET OF type_name

    RANGE           shift and go to state 226


state 207

    (141) writeln_args -> type COMMA writeln_args .

    RPAREN          reduce using rule 141 (writeln_args -> type COMMA writeln_args .)


state 208

    (119) arg_list -> expressionGeneric COMMA . arg_list
    (119) arg_list -> . expressionGeneric COMMA arg_list
    (120) arg_list -> . expressionGeneric
    (121) arg_list -> .
    (27) expressionGeneric -> . expression
    (28) expressionGeneric -> . expressionGeneric comparator expression
    (29) expression -> . term
    (30) expression -> . expression operationAdd term
    (31) term -> . fator
    (32) term -> . term operationMul fator
    (33) fator -> . type
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    RPAREN          reduce using rule 121 (arg_list -> .)
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    expressionGeneric              shift and go to state 176
    arg_list                       shift and go to state 211
    expression                     shift and go to state 71
    term                           shift and go to state 72
    fator                          shift and go to state 73
    type                           shift and go to state 74
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 209

    (104) length -> LENGTH LPAREN type . RPAREN

    RPAREN          shift and go to state 227


state 210

    (102) procedure_arg_list -> expressionGeneric COMMA procedure_arg_list .

    RPAREN          reduce using rule 102 (procedure_arg_list -> expressionGeneric COMMA procedure_arg_list .)


state 211

    (119) arg_list -> expressionGeneric COMMA arg_list .

    RPAREN          reduce using rule 119 (arg_list -> expressionGeneric COMMA arg_list .)


state 212

    (123) cond_if -> IF condition THEN statement ELSE . statement
    (124) cond_if -> IF condition THEN statement ELSE . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (129) if_body -> . BEGIN statements END
    (140) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT expressionGeneric
    (25) assignment -> . type ASSIGNMENT length
    (26) assignment -> . type ASSIGNMENT negation
    (100) procedure_call -> . prepare_func_call
    (101) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (122) cond_if -> . IF condition THEN statement
    (123) cond_if -> . IF condition THEN statement ELSE statement
    (124) cond_if -> . IF condition THEN statement ELSE if_body
    (125) cond_if -> . IF condition THEN if_body
    (126) cond_if -> . IF condition THEN if_body ELSE if_body
    (127) cond_if -> . IF condition THEN if_body ELSE statement
    (136) while_loop -> . WHILE condition DO statement
    (137) while_loop -> . WHILE condition DO if_body
    (132) for_loop -> . FOR assignment to type DO statement
    (133) for_loop -> . FOR assignment to type DO if_body
    (134) for_loop -> . FOR assignment downto type DO statement
    (135) for_loop -> . FOR assignment downto type DO if_body
    (138) repeat_loop -> . REPEAT statements UNTIL condition
    (139) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (118) prepare_func_call -> . IDENTIFIER
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN

    BEGIN           shift and go to state 186
    WRITELN         shift and go to state 36
    IF              shift and go to state 40
    WHILE           shift and go to state 41
    FOR             shift and go to state 42
    REPEAT          shift and go to state 43
    READLN          shift and go to state 44
    IDENTIFIER      shift and go to state 54
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    LPAREN          shift and go to state 37

    statement                      shift and go to state 228
    if_body                        shift and go to state 229
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 38
    prepare_func_call              shift and go to state 39
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53

state 213

    (126) cond_if -> IF condition THEN if_body ELSE . if_body
    (127) cond_if -> IF condition THEN if_body ELSE . statement
    (129) if_body -> . BEGIN statements END
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (140) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT expressionGeneric
    (25) assignment -> . type ASSIGNMENT length
    (26) assignment -> . type ASSIGNMENT negation
    (100) procedure_call -> . prepare_func_call
    (101) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (122) cond_if -> . IF condition THEN statement
    (123) cond_if -> . IF condition THEN statement ELSE statement
    (124) cond_if -> . IF condition THEN statement ELSE if_body
    (125) cond_if -> . IF condition THEN if_body
    (126) cond_if -> . IF condition THEN if_body ELSE if_body
    (127) cond_if -> . IF condition THEN if_body ELSE statement
    (136) while_loop -> . WHILE condition DO statement
    (137) while_loop -> . WHILE condition DO if_body
    (132) for_loop -> . FOR assignment to type DO statement
    (133) for_loop -> . FOR assignment to type DO if_body
    (134) for_loop -> . FOR assignment downto type DO statement
    (135) for_loop -> . FOR assignment downto type DO if_body
    (138) repeat_loop -> . REPEAT statements UNTIL condition
    (139) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (118) prepare_func_call -> . IDENTIFIER
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN

    BEGIN           shift and go to state 186
    WRITELN         shift and go to state 36
    IF              shift and go to state 40
    WHILE           shift and go to state 41
    FOR             shift and go to state 42
    REPEAT          shift and go to state 43
    READLN          shift and go to state 44
    IDENTIFIER      shift and go to state 54
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    LPAREN          shift and go to state 37

    if_body                        shift and go to state 230
    statement                      shift and go to state 231
    writeln                        shift and go to state 28
    assignment                     shift and go to state 29
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    type                           shift and go to state 38
    prepare_func_call              shift and go to state 39
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53

state 214

    (129) if_body -> BEGIN statements . END

    END             shift and go to state 232


state 215

    (132) for_loop -> FOR assignment to type DO . statement
    (133) for_loop -> FOR assignment to type DO . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (129) if_body -> . BEGIN statements END
    (140) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT expressionGeneric
    (25) assignment -> . type ASSIGNMENT length
    (26) assignment -> . type ASSIGNMENT negation
    (100) procedure_call -> . prepare_func_call
    (101) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (122) cond_if -> . IF condition THEN statement
    (123) cond_if -> . IF condition THEN statement ELSE statement
    (124) cond_if -> . IF condition THEN statement ELSE if_body
    (125) cond_if -> . IF condition THEN if_body
    (126) cond_if -> . IF condition THEN if_body ELSE if_body
    (127) cond_if -> . IF condition THEN if_body ELSE statement
    (136) while_loop -> . WHILE condition DO statement
    (137) while_loop -> . WHILE condition DO if_body
    (132) for_loop -> . FOR assignment to type DO statement
    (133) for_loop -> . FOR assignment to type DO if_body
    (134) for_loop -> . FOR assignment downto type DO statement
    (135) for_loop -> . FOR assignment downto type DO if_body
    (138) repeat_loop -> . REPEAT statements UNTIL condition
    (139) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (118) prepare_func_call -> . IDENTIFIER
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN

    BEGIN           shift and go to state 186
    WRITELN         shift and go to state 36
    IF              shift and go to state 40
    WHILE           shift and go to state 41
    FOR             shift and go to state 42
    REPEAT          shift and go to state 43
    READLN          shift and go to state 44
    IDENTIFIER      shift and go to state 54
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    LPAREN          shift and go to state 37

    assignment                     shift and go to state 29
    type                           shift and go to state 38
    statement                      shift and go to state 233
    if_body                        shift and go to state 234
    writeln                        shift and go to state 28
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    prepare_func_call              shift and go to state 39
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53

state 216

    (134) for_loop -> FOR assignment downto type DO . statement
    (135) for_loop -> FOR assignment downto type DO . if_body
    (16) statement -> . writeln
    (17) statement -> . assignment
    (18) statement -> . procedure_call
    (19) statement -> . cond_if
    (20) statement -> . while_loop
    (21) statement -> . for_loop
    (22) statement -> . repeat_loop
    (23) statement -> . readln
    (129) if_body -> . BEGIN statements END
    (140) writeln -> . WRITELN LPAREN writeln_args RPAREN
    (24) assignment -> . type ASSIGNMENT expressionGeneric
    (25) assignment -> . type ASSIGNMENT length
    (26) assignment -> . type ASSIGNMENT negation
    (100) procedure_call -> . prepare_func_call
    (101) procedure_call -> . prepare_func_call LPAREN procedure_arg_list RPAREN
    (122) cond_if -> . IF condition THEN statement
    (123) cond_if -> . IF condition THEN statement ELSE statement
    (124) cond_if -> . IF condition THEN statement ELSE if_body
    (125) cond_if -> . IF condition THEN if_body
    (126) cond_if -> . IF condition THEN if_body ELSE if_body
    (127) cond_if -> . IF condition THEN if_body ELSE statement
    (136) while_loop -> . WHILE condition DO statement
    (137) while_loop -> . WHILE condition DO if_body
    (132) for_loop -> . FOR assignment to type DO statement
    (133) for_loop -> . FOR assignment to type DO if_body
    (134) for_loop -> . FOR assignment downto type DO statement
    (135) for_loop -> . FOR assignment downto type DO if_body
    (138) repeat_loop -> . REPEAT statements UNTIL condition
    (139) readln -> . READLN LPAREN type RPAREN
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (118) prepare_func_call -> . IDENTIFIER
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN

    BEGIN           shift and go to state 186
    WRITELN         shift and go to state 36
    IF              shift and go to state 40
    WHILE           shift and go to state 41
    FOR             shift and go to state 42
    REPEAT          shift and go to state 43
    READLN          shift and go to state 44
    IDENTIFIER      shift and go to state 54
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    LPAREN          shift and go to state 37

    assignment                     shift and go to state 29
    type                           shift and go to state 38
    statement                      shift and go to state 235
    if_body                        shift and go to state 236
    writeln                        shift and go to state 28
    procedure_call                 shift and go to state 30
    cond_if                        shift and go to state 31
    while_loop                     shift and go to state 32
    for_loop                       shift and go to state 33
    repeat_loop                    shift and go to state 34
    readln                         shift and go to state 35
    prepare_func_call              shift and go to state 39
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53

state 217

    (107) function_with_vars -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .

    VAR             reduce using rule 107 (function_with_vars -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)
    BEGIN           reduce using rule 107 (function_with_vars -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)
    PROCEDURE       reduce using rule 107 (function_with_vars -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)
    FUNCTION        reduce using rule 107 (function_with_vars -> func_header SEMICOLON VAR func_variable_declaration func_body SEMICOLON .)


state 218

    (114) func_variable_declaration -> identifier_list COLON type_name . SEMICOLON func_variable_declaration
    (115) func_variable_declaration -> identifier_list COLON type_name . SEMICOLON

    SEMICOLON       shift and go to state 237


state 219

    (95) procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 238


state 220

    (99) procedure_body -> BEGIN statements END .

    SEMICOLON       reduce using rule 99 (procedure_body -> BEGIN statements END .)


state 221

    (94) procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON . procedure_body SEMICOLON
    (96) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON . VAR func_variable_declaration procedure_body SEMICOLON
    (99) procedure_body -> . BEGIN statements END

    VAR             shift and go to state 240
    BEGIN           shift and go to state 163

    procedure_body                 shift and go to state 239

state 222

    (111) func_args -> func_arglist SEMICOLON func_args .

    RPAREN          reduce using rule 111 (func_args -> func_arglist SEMICOLON func_args .)


state 223

    (113) func_arglist -> identifier_list COLON type_name .

    SEMICOLON       reduce using rule 113 (func_arglist -> identifier_list COLON type_name .)
    RPAREN          reduce using rule 113 (func_arglist -> identifier_list COLON type_name .)


state 224

    (109) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON . type_name
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 93
    NREAL           shift and go to state 94
    NSTRING         shift and go to state 95
    NCHAR           shift and go to state 96
    NBOOLEAN        shift and go to state 97
    ARRAY           shift and go to state 99

    type_name                      shift and go to state 241
    array_type                     shift and go to state 98

state 225

    (110) func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name .

    SEMICOLON       reduce using rule 110 (func_header -> FUNCTION IDENTIFIER LPAREN RPAREN COLON type_name .)


state 226

    (11) array_type -> ARRAY LBRACKET type RANGE . type RBRACKET OF type_name
    (48) type -> . integer
    (49) type -> . real
    (50) type -> . string
    (51) type -> . char
    (52) type -> . boolean
    (53) type -> . identifier
    (54) type -> . func_call
    (55) type -> . array_access
    (56) type -> . expression_paren
    (57) integer -> . INTEGER
    (58) real -> . REAL
    (59) string -> . STRING
    (60) char -> . CHAR
    (61) boolean -> . BOOLEAN
    (62) identifier -> . IDENTIFIER
    (117) func_call -> . prepare_func_call LPAREN arg_list RPAREN
    (12) array_access -> . IDENTIFIER LBRACKET expressionGeneric RBRACKET
    (34) expression_paren -> . LPAREN expressionGeneric RPAREN
    (118) prepare_func_call -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    BOOLEAN         shift and go to state 59
    IDENTIFIER      shift and go to state 75
    LPAREN          shift and go to state 37

    type                           shift and go to state 242
    integer                        shift and go to state 45
    real                           shift and go to state 46
    string                         shift and go to state 47
    char                           shift and go to state 48
    boolean                        shift and go to state 49
    identifier                     shift and go to state 50
    func_call                      shift and go to state 51
    array_access                   shift and go to state 52
    expression_paren               shift and go to state 53
    prepare_func_call              shift and go to state 76

state 227

    (104) length -> LENGTH LPAREN type RPAREN .

    SEMICOLON       reduce using rule 104 (length -> LENGTH LPAREN type RPAREN .)
    TO              reduce using rule 104 (length -> LENGTH LPAREN type RPAREN .)
    DOWNTO          reduce using rule 104 (length -> LENGTH LPAREN type RPAREN .)
    ELSE            reduce using rule 104 (length -> LENGTH LPAREN type RPAREN .)


state 228

    (123) cond_if -> IF condition THEN statement ELSE statement .

    SEMICOLON       reduce using rule 123 (cond_if -> IF condition THEN statement ELSE statement .)
    ELSE            reduce using rule 123 (cond_if -> IF condition THEN statement ELSE statement .)


state 229

    (124) cond_if -> IF condition THEN statement ELSE if_body .

    SEMICOLON       reduce using rule 124 (cond_if -> IF condition THEN statement ELSE if_body .)
    ELSE            reduce using rule 124 (cond_if -> IF condition THEN statement ELSE if_body .)


state 230

    (126) cond_if -> IF condition THEN if_body ELSE if_body .

    SEMICOLON       reduce using rule 126 (cond_if -> IF condition THEN if_body ELSE if_body .)
    ELSE            reduce using rule 126 (cond_if -> IF condition THEN if_body ELSE if_body .)


state 231

    (127) cond_if -> IF condition THEN if_body ELSE statement .

    SEMICOLON       reduce using rule 127 (cond_if -> IF condition THEN if_body ELSE statement .)
    ELSE            reduce using rule 127 (cond_if -> IF condition THEN if_body ELSE statement .)


state 232

    (129) if_body -> BEGIN statements END .

    ELSE            reduce using rule 129 (if_body -> BEGIN statements END .)
    SEMICOLON       reduce using rule 129 (if_body -> BEGIN statements END .)


state 233

    (132) for_loop -> FOR assignment to type DO statement .

    SEMICOLON       reduce using rule 132 (for_loop -> FOR assignment to type DO statement .)
    ELSE            reduce using rule 132 (for_loop -> FOR assignment to type DO statement .)


state 234

    (133) for_loop -> FOR assignment to type DO if_body .

    SEMICOLON       reduce using rule 133 (for_loop -> FOR assignment to type DO if_body .)
    ELSE            reduce using rule 133 (for_loop -> FOR assignment to type DO if_body .)


state 235

    (134) for_loop -> FOR assignment downto type DO statement .

    SEMICOLON       reduce using rule 134 (for_loop -> FOR assignment downto type DO statement .)
    ELSE            reduce using rule 134 (for_loop -> FOR assignment downto type DO statement .)


state 236

    (135) for_loop -> FOR assignment downto type DO if_body .

    SEMICOLON       reduce using rule 135 (for_loop -> FOR assignment downto type DO if_body .)
    ELSE            reduce using rule 135 (for_loop -> FOR assignment downto type DO if_body .)


state 237

    (114) func_variable_declaration -> identifier_list COLON type_name SEMICOLON . func_variable_declaration
    (115) func_variable_declaration -> identifier_list COLON type_name SEMICOLON .
    (114) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON func_variable_declaration
    (115) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    BEGIN           reduce using rule 115 (func_variable_declaration -> identifier_list COLON type_name SEMICOLON .)
    IDENTIFIER      shift and go to state 23

    identifier_list                shift and go to state 158
    func_variable_declaration      shift and go to state 243

state 238

    (95) procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .

    VAR             reduce using rule 95 (procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    BEGIN           reduce using rule 95 (procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 95 (procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 95 (procedure_no_args_vars -> PROCEDURE IDENTIFIER SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)


state 239

    (94) procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 244


state 240

    (96) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR . func_variable_declaration procedure_body SEMICOLON
    (114) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON func_variable_declaration
    (115) func_variable_declaration -> . identifier_list COLON type_name SEMICOLON
    (9) identifier_list -> . IDENTIFIER COMMA identifier_list
    (10) identifier_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 23

    func_variable_declaration      shift and go to state 245
    identifier_list                shift and go to state 158

state 241

    (109) func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name .

    SEMICOLON       reduce using rule 109 (func_header -> FUNCTION IDENTIFIER LPAREN func_args RPAREN COLON type_name .)


state 242

    (11) array_type -> ARRAY LBRACKET type RANGE type . RBRACKET OF type_name

    RBRACKET        shift and go to state 246


state 243

    (114) func_variable_declaration -> identifier_list COLON type_name SEMICOLON func_variable_declaration .

    BEGIN           reduce using rule 114 (func_variable_declaration -> identifier_list COLON type_name SEMICOLON func_variable_declaration .)


state 244

    (94) procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .

    VAR             reduce using rule 94 (procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .)
    BEGIN           reduce using rule 94 (procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 94 (procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 94 (procedure_args_no_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON procedure_body SEMICOLON .)


state 245

    (96) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration . procedure_body SEMICOLON
    (99) procedure_body -> . BEGIN statements END

    BEGIN           shift and go to state 163

    procedure_body                 shift and go to state 247

state 246

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET . OF type_name

    OF              shift and go to state 248


state 247

    (96) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body . SEMICOLON

    SEMICOLON       shift and go to state 249


state 248

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF . type_name
    (42) type_name -> . NINTEGER
    (43) type_name -> . NREAL
    (44) type_name -> . NSTRING
    (45) type_name -> . NCHAR
    (46) type_name -> . NBOOLEAN
    (47) type_name -> . array_type
    (11) array_type -> . ARRAY LBRACKET type RANGE type RBRACKET OF type_name

    NINTEGER        shift and go to state 93
    NREAL           shift and go to state 94
    NSTRING         shift and go to state 95
    NCHAR           shift and go to state 96
    NBOOLEAN        shift and go to state 97
    ARRAY           shift and go to state 99

    type_name                      shift and go to state 250
    array_type                     shift and go to state 98

state 249

    (96) procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .

    VAR             reduce using rule 96 (procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    BEGIN           reduce using rule 96 (procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    PROCEDURE       reduce using rule 96 (procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)
    FUNCTION        reduce using rule 96 (procedure_args_vars -> PROCEDURE IDENTIFIER LPAREN func_args RPAREN SEMICOLON VAR func_variable_declaration procedure_body SEMICOLON .)


state 250

    (11) array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .

    SEMICOLON       reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)
    RPAREN          reduce using rule 11 (array_type -> ARRAY LBRACKET type RANGE type RBRACKET OF type_name .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 184 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 185 resolved as shift
WARNING: reduce/reduce conflict in state 147 resolved using rule (procedure_arg_list -> expressionGeneric)
WARNING: rejected rule (arg_list -> expressionGeneric) in state 147
